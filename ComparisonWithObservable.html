<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Comparison with IObservable
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="">

    <link rel="stylesheet" id="theme_link" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.6.0/materia/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns" crossorigin="anonymous"></script>

    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico">
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/navbar-fixed-left.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-light bg-secondary fixed-left" id="fsdocs-nav">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse navbar-nav-scroll" id="navbarsExampleDefault">
            <a href="/FSharp.Control.AsyncSeq/"><img id="fsdocs-logo" src="/FSharp.Control.AsyncSeq/img/logo.png" /></a>
            <!-- BEGIN SEARCH BOX: this adds support for the search box -->
            <div id="header">
                <div class="searchbox" id="fsdocs-searchbox">
                    <label for="search-by">
                        <i class="fas fa-search"></i>
                    </label>
                    <input data-search-input="" id="search-by" type="search" placeholder="Search..." />
                    <span data-search-clear="">
                        <i class="fas fa-times"></i>
                    </span>
                </div>
            </div>

            <!-- END SEARCH BOX: this adds support for the search box -->
            <ul class="navbar-nav">
                <li class="nav-header">Links</li>
                <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License</a></li>
                <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                <li class="nav-header">
  Documentation
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/ComparisonWithObservable.html">
    Comparison with IObservable

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeqExamples.html">
    F# AsyncSeq Examples

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeq.html">
    F# Async: FSharp.Control.AsyncSeq

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/terminology.html">
    Terminology

  </a>
</li>
                {{fsdocs-list-of-namespaces}}
            </ul>
        </div>
    </nav>
    <div class="container">
        <div class="masthead">
            <h3 class="muted"><a href="/FSharp.Control.AsyncSeq/">FSharp.Control.AsyncSeq</a></h3>
        </div>
        <hr />
        <div class="container" id="fsdocs-content">
            <p><a href="https://mybinder.org/v2/gh/fsprojects/FSharp.Control.AsyncSeq/gh-pages?filepath=AsyncSeq.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a></p>
<h1><a name="Comparison-with-IObservable" class="anchor" href="#Comparison-with-IObservable">Comparison with IObservable</a></h1>
<p>Both <code>IObservable&lt;'T&gt;</code> and <code>AsyncSeq&lt;'T&gt;</code> represent collections of items and both provide similar operations
for transformation and composition. The central difference between the two is that the former uses a <em>synchronous push</em>
to a subscriber and the latter uses an <em>asynchronous pull</em> by a consumer.
Consumers of an <code>IObservable&lt;'T&gt;</code> <em>subscribe</em> to receive notifications about
new items or the end of the sequence. By contrast, consumers of an <code>AsyncSeq&lt;'T&gt;</code> <em>asynchronously retrieve</em> subsequent items on their own
terms. Some domains are more naturally modeled with one or the other, however it is less clear which is a more
suitable tool for a specific task. In many cases, a combination of the two provides the optimal solution and
restricting yourself to one, while simplifying the programming model, can lead one to view all problems as a nail.</p>
<p>A more specific difference between the two is that <code>IObservable&lt;'T&gt;</code> subscribers have the basic type <code>'T -&gt; unit</code>
and are therefore inherently synchronous and imperative. The observer can certainly make a blocking call, but this
can defeat the purpose of the observable sequence all together. Alternatively, the observer can spawn an operation, but
this can break composition because one can no longer rely on the observer returning to determine that it has
completed. With the observable model however, we can model blocking operations through composition on sequences rather
than observers.</p>
<p>To illustrate, let's try to implement the above Tweet retrieval, filtering and storage workflow using observable sequences.
Suppose we already have an observable sequence representing tweets <code>IObservable&lt;Tweet&gt;</code> and we simply wish
to filter it and store the resulting tweets. The function <code>Observable.filter</code> allows one to filter observable
sequences based on a predicate, however in this case it doesn't quite cut it because the predicate passed to it must
be synchronous <code>'T -&gt; bool</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">System</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">tweetsObs</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="if">IObservable</span><span class="pn">&lt;</span><span class="id">Tweet</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="fn">failwith</span> <span class="s">&quot;TODO: create observable&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="id">filteredTweetsObs</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs2', 6)" onmouseover="showTip(event, 'fs2', 6)" class="id">tweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs7', 8)" onmouseover="showTip(event, 'fs7', 8)" class="id">filter</span> <span class="pn">(</span><span class="id">filterTweet</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs8', 9)" onmouseover="showTip(event, 'fs8', 9)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="id">RunSynchronously</span><span class="pn">)</span> <span class="c">// blocking IO-call!</span>
</code></pre>
<p>To remedy the blocking IO-call we can better adapt the filtering function to the <code>IObservable&lt;'T&gt;</code> model. A value
of type <code>Async&lt;'T&gt;</code> can be modeled as an <code>IObservable&lt;'T&gt;</code> with one element. Suppose that we have
<code>Tweet -&gt; IObservable&lt;bool&gt;</code>. We can define a few helper operators on observables to allow filtering using
an asynchronous predicate as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">module</span> <span onmouseout="hideTip(event, 'fs6', 11)" onmouseover="showTip(event, 'fs6', 11)" class="m">Observable</span> <span class="o">=</span>
  
  <span class="c">/// a |&gt; Async.StartAsTask |&gt; (fun t -&gt; t.ToObservable())</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="fn">ofAsync</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs11', 13)" onmouseover="showTip(event, 'fs11', 13)" class="fn">a</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs8', 14)" onmouseover="showTip(event, 'fs8', 14)" class="rt">Async</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 15)" onmouseover="showTip(event, 'fs3', 15)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs4', 16)" onmouseover="showTip(event, 'fs4', 16)" class="fn">failwith</span> <span class="s">&quot;TODO&quot;</span>

  <span class="c">/// Observable.SelectMany</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 17)" onmouseover="showTip(event, 'fs12', 17)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs13', 18)" onmouseover="showTip(event, 'fs13', 18)" class="fn">f</span><span class="pn">:</span><span class="ta">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs3', 19)" onmouseover="showTip(event, 'fs3', 19)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">b</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs14', 20)" onmouseover="showTip(event, 'fs14', 20)" class="fn">o</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs3', 21)" onmouseover="showTip(event, 'fs3', 21)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 22)" onmouseover="showTip(event, 'fs3', 22)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">b</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs4', 23)" onmouseover="showTip(event, 'fs4', 23)" class="fn">failwith</span> <span class="s">&quot;TODO&quot;</span>

  <span class="c">/// Filter an observable sequence using a predicate producing a observable</span>
  <span class="c">/// which emits a single boolean value.</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 24)" onmouseover="showTip(event, 'fs15', 24)" class="fn">filterObs</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs16', 25)" onmouseover="showTip(event, 'fs16', 25)" class="fn">f</span><span class="pn">:</span><span class="ta">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs3', 26)" onmouseover="showTip(event, 'fs3', 26)" class="if">IObservable</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs17', 27)" onmouseover="showTip(event, 'fs17', 27)" class="vt">bool</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 28)" onmouseover="showTip(event, 'fs3', 28)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs3', 29)" onmouseover="showTip(event, 'fs3', 29)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs12', 30)" onmouseover="showTip(event, 'fs12', 30)" class="fn">bind</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs18', 31)" onmouseover="showTip(event, 'fs18', 31)" class="fn">a</span> <span class="k">-&gt;</span> 
      <span onmouseout="hideTip(event, 'fs16', 32)" onmouseover="showTip(event, 'fs16', 32)" class="fn">f</span> <span onmouseout="hideTip(event, 'fs18', 33)" onmouseover="showTip(event, 'fs18', 33)" class="fn">a</span>
      <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 34)" onmouseover="showTip(event, 'fs6', 34)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs19', 35)" onmouseover="showTip(event, 'fs19', 35)" class="id">choose</span> <span class="pn">(</span><span class="k">function</span>
        <span class="pn">|</span> <span class="k">true</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs20', 36)" onmouseover="showTip(event, 'fs20', 36)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs18', 37)" onmouseover="showTip(event, 'fs18', 37)" class="fn">a</span>
        <span class="pn">|</span> <span class="k">false</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs21', 38)" onmouseover="showTip(event, 'fs21', 38)" class="uc">None</span>
      <span class="pn">)</span>
  
  <span class="c">/// Filter an observable sequence using a predicate which returns an async</span>
  <span class="c">/// computation producing a boolean value.</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 39)" onmouseover="showTip(event, 'fs22', 39)" class="fn">filterAsync</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 40)" onmouseover="showTip(event, 'fs23', 40)" class="fn">f</span><span class="pn">:</span><span class="ta">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs8', 41)" onmouseover="showTip(event, 'fs8', 41)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs17', 42)" onmouseover="showTip(event, 'fs17', 42)" class="vt">bool</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 43)" onmouseover="showTip(event, 'fs3', 43)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs3', 44)" onmouseover="showTip(event, 'fs3', 44)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs15', 45)" onmouseover="showTip(event, 'fs15', 45)" class="fn">filterObs</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 46)" onmouseover="showTip(event, 'fs23', 46)" class="fn">f</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs10', 47)" onmouseover="showTip(event, 'fs10', 47)" class="fn">ofAsync</span><span class="pn">)</span>

  <span class="c">/// Maps over an observable sequence using an async-returning function.</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 48)" onmouseover="showTip(event, 'fs24', 48)" class="fn">mapAsync</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs25', 49)" onmouseover="showTip(event, 'fs25', 49)" class="fn">f</span><span class="pn">:</span><span class="ta">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs8', 50)" onmouseover="showTip(event, 'fs8', 50)" class="rt">Async</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">b</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 51)" onmouseover="showTip(event, 'fs3', 51)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">a</span><span class="pn">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs3', 52)" onmouseover="showTip(event, 'fs3', 52)" class="if">IObservable</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">b</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs12', 53)" onmouseover="showTip(event, 'fs12', 53)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs25', 54)" onmouseover="showTip(event, 'fs25', 54)" class="fn">f</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs10', 55)" onmouseover="showTip(event, 'fs10', 55)" class="fn">ofAsync</span><span class="pn">)</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 56)" onmouseover="showTip(event, 'fs26', 56)" class="id">filteredTweetsObs&#39;</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 57)" onmouseover="showTip(event, 'fs3', 57)" class="if">IObservable</span><span class="pn">&lt;</span><span class="id">Tweet</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs5', 58)" onmouseover="showTip(event, 'fs5', 58)" class="id">filteredTweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs27', 59)" onmouseover="showTip(event, 'fs27', 59)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 60)" onmouseover="showTip(event, 'fs22', 60)" class="id">filterAsync</span> <span class="id">filterTweet</span>
</code></pre>
<p>With a little effort, we were able to adapt <code>IObservable&lt;'a&gt;</code> to our needs. Next let's try implementing the storage of
filtered tweets. Again, we can adapt the function <code>storeTweet</code> defined above to the observable model and bind the
observable of filtered tweets to it:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 61)" onmouseover="showTip(event, 'fs28', 61)" class="id">storedTweetsObs</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 62)" onmouseover="showTip(event, 'fs3', 62)" class="if">IObservable</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs29', 63)" onmouseover="showTip(event, 'fs29', 63)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs26', 64)" onmouseover="showTip(event, 'fs26', 64)" class="id">filteredTweetsObs&#39;</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs27', 65)" onmouseover="showTip(event, 'fs27', 65)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs24', 66)" onmouseover="showTip(event, 'fs24', 66)" class="id">mapAsync</span> <span class="id">storeTweet</span>
</code></pre>
<p>The observable sequence <code>storedTweetsObs</code> will produces a value each time a filtered tweet is stored. The entire
workflow can be expressed as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 67)" onmouseover="showTip(event, 'fs30', 67)" class="id">storedTeetsObs&#39;</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs3', 68)" onmouseover="showTip(event, 'fs3', 68)" class="if">IObservable</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs29', 69)" onmouseover="showTip(event, 'fs29', 69)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs2', 70)" onmouseover="showTip(event, 'fs2', 70)" class="id">tweetsObs</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs27', 71)" onmouseover="showTip(event, 'fs27', 71)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 72)" onmouseover="showTip(event, 'fs22', 72)" class="id">filterAsync</span> <span class="id">filterTweet</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs27', 73)" onmouseover="showTip(event, 'fs27', 73)" class="m">Observable</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs24', 74)" onmouseover="showTip(event, 'fs24', 74)" class="id">mapAsync</span> <span class="id">storeTweet</span>
</code></pre>
<p>Overall, both solutions are succinct and composable and deciding which one to use can ultimately be a matter of preference.
Some things to consider are the "synchronous push" vs. "asynchronous pull" semantics. On the one hand, tweets are pushed based - the consumer has no control
over their generation. On the other hand, the program at hand will process the tweets on its own terms regardless of how quickly
they are being generated. Moreover, the underlying Twitter API will likely utilize a request-reply protocol to retrieve batches of
tweets from persistent storage. As such, the distinction between "synchronous push" vs. "asynchronous pull" becomes less interesting. If the underlying source
is truly push-based, then one can buffer its output and consume it using an asynchronous sequence. If the underlying source is pull-based,
then one can turn it into an observable sequence by first pulling, then pushing. Note however that in a true real-time reactive system,
notifications must be pushed immediately without delay.</p>
<p>Upon closer inspection, the consumption approaches between the two models aren't all too different. While <code>AsyncSeq</code> is based on an asynchronous-pull operation,
it is usually consumed using an operator such as <code>AsyncSeq.iterAsync</code> as shown above. This is a function of type
<code>('T -&gt; Async&lt;unit&gt;) -&gt; AsyncSeq&lt;'T&gt; -&gt; Async&lt;unit&gt;</code> where the first argument is a function <code>'T -&gt; Async&lt;unit&gt;</code> which performs
some work on an item of the sequence and is applied repeatedly to subsequent items. In a sense, <code>iterAsync</code> <em>pushes</em> values to this
function. The primary difference from observers of observable sequences is the return type <code>Async&lt;unit&gt;</code> rather than simply <code>unit</code>.</p>
<h2><a name="Related-Articles" class="anchor" href="#Related-Articles">Related Articles</a></h2>
<ul>
<li><a href="http://tomasp.net/blog/async-sequences.aspx/">Programming with F# asynchronous sequences</a></li>
</ul>

            <div class="fsdocs-tip" id="fs1">namespace System</div>
<div class="fsdocs-tip" id="fs2">val tweetsObs : IObservable&lt;obj&gt;</div>
<div class="fsdocs-tip" id="fs3">type IObservable&lt;&#39;T&gt; =
  member Subscribe : observer: IObserver&lt;&#39;T&gt; -&gt; IDisposable<br /><em>&lt;summary&gt;Defines a provider for push-based notification.&lt;/summary&gt;<br />&lt;typeparam name=&quot;T&quot;&gt;The object that provides notification information.&lt;/typeparam&gt;</em></div>
<div class="fsdocs-tip" id="fs4">val failwith : message:string -&gt; &#39;T<br /><em>&lt;summary&gt;Throw a &lt;see cref=&quot;T:System.Exception&quot; /&gt; exception.&lt;/summary&gt;<br />&lt;param name=&quot;message&quot;&gt;The exception message.&lt;/param&gt;<br />&lt;returns&gt;The result value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs5">val filteredTweetsObs : IObservable&lt;obj&gt;</div>
<div class="fsdocs-tip" id="fs6">module Observable

from Microsoft.FSharp.Control<br /><em>&lt;summary&gt;Contains operations for working with first class event and other observable objects.&lt;/summary&gt;<br />&lt;category index=&quot;3&quot;&gt;Events and Observables&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs7">val filter : predicate:(&#39;T -&gt; bool) -&gt; source:IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;T&gt;<br /><em>&lt;summary&gt;Returns an observable which filters the observations of the source 
 by the given function. The observable will see only those observations
 for which the predicate returns true. The predicate is executed once for 
 each subscribed observer. The returned object also propagates error 
 observations arising from the source and completes when the source completes.&lt;/summary&gt;<br />&lt;param name=&quot;predicate&quot;&gt;The function to apply to observations to determine if it should
 be kept.&lt;/param&gt;<br />&lt;param name=&quot;source&quot;&gt;The input Observable.&lt;/param&gt;<br />&lt;returns&gt;An Observable that filters observations based on &lt;c&gt;filter&lt;/c&gt;.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs8">Multiple items<br />type Async =
  static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)
  static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)
  static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt; + 1 overload
  static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member CancelDefaultToken : unit -&gt; unit
  static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;
  static member Choice : computations:seq&lt;Async&lt;&#39;T option&gt;&gt; -&gt; Async&lt;&#39;T option&gt;
  static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; + 3 overloads
  static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;
  ...<br /><em>&lt;summary&gt;Holds static members for creating and manipulating asynchronous computations.&lt;/summary&gt;<br />&lt;remarks&gt;
  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em><br /><br />--------------------<br />type Async&lt;&#39;T&gt; =<br /><em>&lt;summary&gt;
 An asynchronous computation, which, when run, will eventually produce a value  of type T, or else raises an exception.
 &lt;/summary&gt;<br />&lt;remarks&gt;
  This type has no members. Asynchronous computations are normally specified either by using an async expression
  or the static methods in the &lt;see cref=&quot;T:Microsoft.FSharp.Control.Async&quot; /&gt; type.

  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;namespacedoc&gt;&lt;summary&gt;
   Library functionality for asynchronous programming, events and agents. See also
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;Asynchronous Programming&lt;/a&gt;, 
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/events&quot;&gt;Events&lt;/a&gt; and
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lazy-expressions&quot;&gt;Lazy Expressions&lt;/a&gt; in the
   F# Language Guide.
 &lt;/summary&gt;&lt;/namespacedoc&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs9">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:Threading.CancellationToken -&gt; &#39;T</div>
<div class="fsdocs-tip" id="fs10">val ofAsync : a:Async&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;<br /><em>&#160;a |&gt; Async.StartAsTask |&gt; (fun t -&gt; t.ToObservable())</em></div>
<div class="fsdocs-tip" id="fs11">val a : Async&lt;&#39;a&gt;</div>
<div class="fsdocs-tip" id="fs12">val bind : f:(&#39;a -&gt; IObservable&lt;&#39;b&gt;) -&gt; o:IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;b&gt;<br /><em>&#160;Observable.SelectMany</em></div>
<div class="fsdocs-tip" id="fs13">val f : (&#39;a -&gt; IObservable&lt;&#39;b&gt;)</div>
<div class="fsdocs-tip" id="fs14">val o : IObservable&lt;&#39;a&gt;</div>
<div class="fsdocs-tip" id="fs15">val filterObs : f:(&#39;a -&gt; IObservable&lt;bool&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;)<br /><em>&#160;Filter an observable sequence using a predicate producing a observable<br />&#160;which emits a single boolean value.</em></div>
<div class="fsdocs-tip" id="fs16">val f : (&#39;a -&gt; IObservable&lt;bool&gt;)</div>
<div class="fsdocs-tip" id="fs17">[&lt;Struct&gt;]
type bool = Boolean<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs18">val a : &#39;a</div>
<div class="fsdocs-tip" id="fs19">val choose : chooser:(&#39;T -&gt; &#39;U option) -&gt; source:IObservable&lt;&#39;T&gt; -&gt; IObservable&lt;&#39;U&gt;<br /><em>&lt;summary&gt;Returns an observable which chooses a projection of observations from the source 
 using the given function. The returned object will trigger observations &lt;c&gt;x&lt;/c&gt;
 for which the splitter returns &lt;c&gt;Some x&lt;/c&gt;. The returned object also propagates 
 all errors arising from the source and completes when the source completes.&lt;/summary&gt;<br />&lt;param name=&quot;chooser&quot;&gt;The function that returns Some for observations to be propagated
 and None for observations to ignore.&lt;/param&gt;<br />&lt;param name=&quot;source&quot;&gt;The input Observable.&lt;/param&gt;<br />&lt;returns&gt;An Observable that only propagates some of the observations from the source.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs20">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The representation of &quot;Value of type &#39;T&quot;&lt;/summary&gt;<br />&lt;param name=&quot;Value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;An option representing the value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs21">union case Option.None: Option&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The representation of &quot;No value&quot;&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs22">val filterAsync : f:(&#39;a -&gt; Async&lt;bool&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;a&gt;)<br /><em>&#160;Filter an observable sequence using a predicate which returns an async<br />&#160;computation producing a boolean value.</em></div>
<div class="fsdocs-tip" id="fs23">val f : (&#39;a -&gt; Async&lt;bool&gt;)</div>
<div class="fsdocs-tip" id="fs24">val mapAsync : f:(&#39;a -&gt; Async&lt;&#39;b&gt;) -&gt; (IObservable&lt;&#39;a&gt; -&gt; IObservable&lt;&#39;b&gt;)<br /><em>&#160;Maps over an observable sequence using an async-returning function.</em></div>
<div class="fsdocs-tip" id="fs25">val f : (&#39;a -&gt; Async&lt;&#39;b&gt;)</div>
<div class="fsdocs-tip" id="fs26">val filteredTweetsObs&#39; : IObservable&lt;obj&gt;</div>
<div class="fsdocs-tip" id="fs27">Multiple items<br />module Observable

from ComparisonWithObservable<br /><br />--------------------<br />module Observable

from Microsoft.FSharp.Control<br /><em>&lt;summary&gt;Contains operations for working with first class event and other observable objects.&lt;/summary&gt;<br />&lt;category index=&quot;3&quot;&gt;Events and Observables&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs28">val storedTweetsObs : IObservable&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs29">type unit = Unit<br /><em>&lt;summary&gt;The type &#39;unit&#39;, which has only one value &quot;()&quot;. This value is special and
 always uses the representation &#39;null&#39;.&lt;/summary&gt;<br />&lt;category index=&quot;1&quot;&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs30">val storedTeetsObs&#39; : IObservable&lt;unit&gt;</div>

        </div>

        <!-- BEGIN SEARCH BOX: this adds support for the search box -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
        <script type="text/javascript">var fsdocs_search_baseurl = '/FSharp.Control.AsyncSeq/';</script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
        <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-search.js"></script>
        <!-- END SEARCH BOX: this adds support for the search box -->
    </div>
</body>

</html>