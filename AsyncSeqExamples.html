<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>F# AsyncSeq Examples
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="">

    <link rel="stylesheet" id="theme_link" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.6.0/materia/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns" crossorigin="anonymous"></script>

    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico">
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/navbar-fixed-left.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-light bg-secondary fixed-left" id="fsdocs-nav">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse navbar-nav-scroll" id="navbarsExampleDefault">
            <a href="/FSharp.Control.AsyncSeq/"><img id="fsdocs-logo" src="/FSharp.Control.AsyncSeq/img/logo.png" /></a>
            <!-- BEGIN SEARCH BOX: this adds support for the search box -->
            <div id="header">
                <div class="searchbox" id="fsdocs-searchbox">
                    <label for="search-by">
                        <i class="fas fa-search"></i>
                    </label>
                    <input data-search-input="" id="search-by" type="search" placeholder="Search..." />
                    <span data-search-clear="">
                        <i class="fas fa-times"></i>
                    </span>
                </div>
            </div>

            <!-- END SEARCH BOX: this adds support for the search box -->
            <ul class="navbar-nav">
                <li class="nav-header">Links</li>
                <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License</a></li>
                <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                <li class="nav-header">
  Documentation
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/ComparisonWithObservable.html">
    Comparison with IObservable

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeqExamples.html">
    F# AsyncSeq Examples

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeq.html">
    F# Async: FSharp.Control.AsyncSeq

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/terminology.html">
    Terminology

  </a>
</li>
                {{fsdocs-list-of-namespaces}}
            </ul>
        </div>
    </nav>
    <div class="container">
        <div class="masthead">
            <h3 class="muted"><a href="/FSharp.Control.AsyncSeq/">FSharp.Control.AsyncSeq</a></h3>
        </div>
        <hr />
        <div class="container" id="fsdocs-content">
            <p><a href="https://mybinder.org/v2/gh/fsprojects/FSharp.Control.AsyncSeq/gh-pages?filepath=AsyncSeqExamples.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a></p>
<h1><a name="F-AsyncSeq-Examples" class="anchor" href="#F-AsyncSeq-Examples">F# AsyncSeq Examples</a></h1>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pp">#r</span> <span class="s">&quot;../../../bin/FSharp.Control.AsyncSeq.dll&quot;</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">System</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">FSharp</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">Control</span>
</code></pre>
<h2><a name="Group-By" class="anchor" href="#Group-By">Group By</a></h2>
<p><code>AsyncSeq.groupBy</code> partitions an input sequence into sub-sequences with respect to the specified <code>projection</code> function. This operation is the asynchronous analog to <code>Seq.groupBy</code>.</p>
<h3><a name="Example-Execution" class="anchor" href="#Example-Execution">Example Execution</a></h3>
<p>An example execution can be depicted visually as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">--------------------------------------------------</span>
<span class="pn">|</span> <span class="id">source</span>  <span class="pn">|</span> <span class="id">a0</span> <span class="pn">|</span> <span class="id">a2</span> <span class="pn">|</span> <span class="id">a3</span> <span class="pn">|</span> <span class="id">a4</span> <span class="pn">|</span> <span class="id">a5</span> <span class="pn">|</span>             <span class="pn">|</span>
<span class="pn">|</span> <span class="id">key</span>     <span class="pn">|</span> <span class="id">k1</span> <span class="pn">|</span> <span class="id">k2</span> <span class="pn">|</span> <span class="id">k1</span> <span class="pn">|</span> <span class="id">k3</span> <span class="pn">|</span>    <span class="pn">|</span>             <span class="pn">|</span> 
<span class="pn">|</span> <span class="id">result</span>  <span class="pn">|</span> <span class="id">k1</span> <span class="pn">*</span> <span class="pn">[</span><span class="id">a1</span><span class="pn">,</span><span class="id">a3</span><span class="pn">]</span> <span class="pn">|</span> <span class="id">k2</span> <span class="pn">*</span> <span class="pn">[</span><span class="id">a2</span><span class="pn">]</span> <span class="pn">|</span> <span class="id">k3</span> <span class="pn">*</span> <span class="pn">[</span><span class="id">a4</span><span class="pn">]</span> <span class="pn">|</span>
<span class="o">--------------------------------------------------</span>
</code></pre>
<h3><a name="Use-Case" class="anchor" href="#Use-Case">Use Case</a></h3>
<p>Suppose we would like to consume a stream of events <code>AsyncSeq&lt;Event&gt;</code> and perform an operation on each event. The operation on each event is of type <code>Event -&gt; Async&lt;unit&gt;</code>. This can be done as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="rt">Event</span> <span class="o">=</span> <span class="pn">{</span>
  <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="prop">entityId</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="vt">int64</span>
  <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="prop">data</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="rt">string</span> 
<span class="pn">}</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 9)" onmouseover="showTip(event, 'fs9', 9)" class="id">stream</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 10)" onmouseover="showTip(event, 'fs10', 10)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs4', 11)" onmouseover="showTip(event, 'fs4', 11)" class="rt">Event</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="fn">failwith</span> <span class="s">&quot;undefined&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="fn">action</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs13', 14)" onmouseover="showTip(event, 'fs13', 14)" class="fn">e</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs4', 15)" onmouseover="showTip(event, 'fs4', 15)" class="rt">Event</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs14', 16)" onmouseover="showTip(event, 'fs14', 16)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs15', 17)" onmouseover="showTip(event, 'fs15', 17)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 18)" onmouseover="showTip(event, 'fs11', 18)" class="fn">failwith</span> <span class="s">&quot;undefined&quot;</span>

<span onmouseout="hideTip(event, 'fs9', 19)" onmouseover="showTip(event, 'fs9', 19)" class="id">stream</span> 
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 20)" onmouseover="showTip(event, 'fs10', 20)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="id">iterAsync</span> <span onmouseout="hideTip(event, 'fs12', 22)" onmouseover="showTip(event, 'fs12', 22)" class="fn">action</span>
</code></pre>
<p>The above workflow will read an event from the stream, perform an operation and then read the next event.
While the read operation and the operation on the event are <em>asynchronous</em>, the stream is processed <em>sequentially</em>.
It may be desirable to parallelize the processing of the stream. Suppose that events correspond to some entity,
such as a shopping cart. Events belonging to some shopping cart must be processed in a sequential order, however they
are independent from events belonging to other shopping carts. Therefore, events belonging to distinct shopping carts
can be processed in parallel. Using <code>AsyncSeq.groupBy</code>, we can partition the stream into a fixed set of sub-streams
and then process the sub-streams in parallel using <code>AsyncSeq.mapAsyncParallel</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs9', 23)" onmouseover="showTip(event, 'fs9', 23)" class="id">stream</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 24)" onmouseover="showTip(event, 'fs10', 24)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 25)" onmouseover="showTip(event, 'fs17', 25)" class="id">groupBy</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs13', 26)" onmouseover="showTip(event, 'fs13', 26)" class="fn">e</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 27)" onmouseover="showTip(event, 'fs18', 27)" class="fn">int</span> <span onmouseout="hideTip(event, 'fs13', 28)" onmouseover="showTip(event, 'fs13', 28)" class="fn">e</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs5', 29)" onmouseover="showTip(event, 'fs5', 29)" class="id">entityId</span> <span class="o">%</span> <span class="n">4</span><span class="pn">)</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 30)" onmouseover="showTip(event, 'fs10', 30)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs19', 31)" onmouseover="showTip(event, 'fs19', 31)" class="id">mapAsyncParallel</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs20', 32)" onmouseover="showTip(event, 'fs20', 32)" class="fn">snd</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs10', 33)" onmouseover="showTip(event, 'fs10', 33)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs16', 34)" onmouseover="showTip(event, 'fs16', 34)" class="id">iterAsync</span> <span onmouseout="hideTip(event, 'fs12', 35)" onmouseover="showTip(event, 'fs12', 35)" class="fn">action</span><span class="pn">)</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 36)" onmouseover="showTip(event, 'fs10', 36)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs21', 37)" onmouseover="showTip(event, 'fs21', 37)" class="id">iter</span> <span onmouseout="hideTip(event, 'fs22', 38)" onmouseover="showTip(event, 'fs22', 38)" class="fn">ignore</span>
</code></pre>
<p><code>AsyncSeq.groupBy</code> partitions the input sequence into sub-sequences based on a key returned by a projection function.
The resulting sub-sequences emit elements when the source sequence emits an element corresponding to the key of the
sub-sequence. Elements of the resulting sequence are pairs of keys and sub-sequences, in this case <code>int * AsyncSeq&lt;Event&gt;</code>. Since by definition, these sub-sequences are independent, they can be processed in parallel. In fact, the sub-sequences <em>must</em> be processed in parallel, because it isn't possible to complete the processing of a sub-sequence until all elements of the source sequence are exhausted.</p>
<p>To continue improving the efficiency of our workflow, we can make use of batching. Specifically, we can read the incoming
events in batches and we can perform actions on entire batches of events.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 39)" onmouseover="showTip(event, 'fs23', 39)" class="id">batchStream</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 40)" onmouseover="showTip(event, 'fs10', 40)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs4', 41)" onmouseover="showTip(event, 'fs4', 41)" class="rt">Event</span><span class="pn">[</span><span class="pn">]</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 42)" onmouseover="showTip(event, 'fs11', 42)" class="fn">failwith</span> <span class="s">&quot;undefined&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 43)" onmouseover="showTip(event, 'fs24', 43)" class="fn">batchAction</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs25', 44)" onmouseover="showTip(event, 'fs25', 44)" class="fn">es</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs4', 45)" onmouseover="showTip(event, 'fs4', 45)" class="rt">Event</span><span class="pn">[</span><span class="pn">]</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs14', 46)" onmouseover="showTip(event, 'fs14', 46)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs15', 47)" onmouseover="showTip(event, 'fs15', 47)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 48)" onmouseover="showTip(event, 'fs11', 48)" class="fn">failwith</span> <span class="s">&quot;undefined&quot;</span>
</code></pre>
<p>Ordering is still important. For example, the batch action could write events into a full-text search index. We would like the full-text search index to be sequentially consistent. As such, the events need to be applied in the order they were emitted. The following workflow has the desired properties:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs23', 49)" onmouseover="showTip(event, 'fs23', 49)" class="id">batchStream</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 50)" onmouseover="showTip(event, 'fs10', 50)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs26', 51)" onmouseover="showTip(event, 'fs26', 51)" class="id">concatSeq</span> <span class="c">// flatten the sequence of event arrays</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 52)" onmouseover="showTip(event, 'fs10', 52)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 53)" onmouseover="showTip(event, 'fs17', 53)" class="id">groupBy</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs13', 54)" onmouseover="showTip(event, 'fs13', 54)" class="fn">e</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 55)" onmouseover="showTip(event, 'fs18', 55)" class="fn">int</span> <span onmouseout="hideTip(event, 'fs13', 56)" onmouseover="showTip(event, 'fs13', 56)" class="fn">e</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs5', 57)" onmouseover="showTip(event, 'fs5', 57)" class="id">entityId</span> <span class="o">%</span> <span class="n">4</span><span class="pn">)</span> <span class="c">// partition into 4 groups</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 58)" onmouseover="showTip(event, 'fs10', 58)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs19', 59)" onmouseover="showTip(event, 'fs19', 59)" class="id">mapAsyncParallel</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs20', 60)" onmouseover="showTip(event, 'fs20', 60)" class="fn">snd</span> 
  <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs10', 61)" onmouseover="showTip(event, 'fs10', 61)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs27', 62)" onmouseover="showTip(event, 'fs27', 62)" class="id">bufferByCountAndTime</span> <span class="n">500</span> <span class="n">1000</span> <span class="c">// buffer sub-sequences</span>
  <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs10', 63)" onmouseover="showTip(event, 'fs10', 63)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs16', 64)" onmouseover="showTip(event, 'fs16', 64)" class="id">iterAsync</span> <span onmouseout="hideTip(event, 'fs24', 65)" onmouseover="showTip(event, 'fs24', 65)" class="fn">batchAction</span><span class="pn">)</span> <span class="c">// perform the batch operation</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 66)" onmouseover="showTip(event, 'fs10', 66)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs21', 67)" onmouseover="showTip(event, 'fs21', 67)" class="id">iter</span> <span onmouseout="hideTip(event, 'fs22', 68)" onmouseover="showTip(event, 'fs22', 68)" class="fn">ignore</span>
</code></pre>
<p>The above workflow:</p>
<ol>
<li>Reads events in batches.</li>
<li>Flattens the batches.</li>
<li>Partitions the events into mutually exclusive sub-sequences.</li>
<li>Buffers elements of each sub-sequence by time and space.</li>
<li>Processes the sub-sequences in parallel, but individual sub-sequences sequentially.</li>
</ol>
<h2><a name="Merge" class="anchor" href="#Merge">Merge</a></h2>
<p><code>AsyncSeq.merge</code> non-deterministically merges two async sequences into one. It is non-deterministic in the sense that the resulting sequence emits elements whenever <em>either</em> input sequence emits a value. Since it isn't always known which will emit a value first, if at all, the operation is non-deterministic. This operation is in contrast to <code>AsyncSeq.zip</code> which also takes two async sequences and returns a single async sequence, but as opposed to emitting an element when <em>either</em> input sequence produces a value, it emits an element when <em>both</em> sequences emit a value. This operation is also in contrast to <code>AsyncSeq.append</code> which concatenates two async sequences, emitting all element of one, followed by all elements of the another.</p>
<h3><a name="Example-Execution-1" class="anchor" href="#Example-Execution-1">Example Execution</a></h3>
<p>An example execution can be depicted visually as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">-----------------------------------------</span>
<span class="pn">|</span> <span class="id">source1</span> <span class="pn">|</span> <span class="id">t0</span> <span class="pn">|</span>    <span class="pn">|</span> <span class="id">t1</span> <span class="pn">|</span>    <span class="pn">|</span>    <span class="pn">|</span> <span class="id">t2</span> <span class="pn">|</span>
<span class="pn">|</span> <span class="id">source2</span> <span class="pn">|</span>    <span class="pn">|</span> <span class="id">u0</span> <span class="pn">|</span>    <span class="pn">|</span>    <span class="pn">|</span> <span class="id">u1</span> <span class="pn">|</span>    <span class="pn">|</span>
<span class="pn">|</span> <span class="id">result</span>  <span class="pn">|</span> <span class="id">t0</span> <span class="pn">|</span> <span class="id">u0</span> <span class="pn">|</span> <span class="id">t1</span> <span class="pn">|</span>    <span class="pn">|</span> <span class="id">u1</span> <span class="pn">|</span> <span class="id">t2</span> <span class="pn">|</span>
<span class="o">-----------------------------------------</span>
</code></pre>
<h3><a name="Use-Case-1" class="anchor" href="#Use-Case-1">Use Case</a></h3>
<p>Suppose you wish to perform an operation when either of two async sequences emits an element. One way to do this is two start consuming both async sequences in parallel. If we would like to perform only one operation at a time, we can use <code>AsyncSeq.merge</code> as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">/// Represents an stream emitting elements on a specified interval.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 69)" onmouseover="showTip(event, 'fs28', 69)" class="fn">intervalMs</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs29', 70)" onmouseover="showTip(event, 'fs29', 70)" class="fn">periodMs</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs18', 71)" onmouseover="showTip(event, 'fs18', 71)" class="vt">int</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs30', 72)" onmouseover="showTip(event, 'fs30', 72)" class="k">asyncSeq</span> <span class="pn">{</span>
  <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs31', 73)" onmouseover="showTip(event, 'fs31', 73)" class="vt">DateTime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 74)" onmouseover="showTip(event, 'fs32', 74)" class="id">UtcNow</span>
  <span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs14', 75)" onmouseover="showTip(event, 'fs14', 75)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs33', 76)" onmouseover="showTip(event, 'fs33', 76)" class="id">Sleep</span> <span onmouseout="hideTip(event, 'fs29', 77)" onmouseover="showTip(event, 'fs29', 77)" class="fn">periodMs</span>
    <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs31', 78)" onmouseover="showTip(event, 'fs31', 78)" class="vt">DateTime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 79)" onmouseover="showTip(event, 'fs32', 79)" class="id">UtcNow</span> <span class="pn">}</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs34', 80)" onmouseover="showTip(event, 'fs34', 80)" class="id">either</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 81)" onmouseover="showTip(event, 'fs10', 81)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs31', 82)" onmouseover="showTip(event, 'fs31', 82)" class="vt">DateTime</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs10', 83)" onmouseover="showTip(event, 'fs10', 83)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs35', 84)" onmouseover="showTip(event, 'fs35', 84)" class="id">merge</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs28', 85)" onmouseover="showTip(event, 'fs28', 85)" class="fn">intervalMs</span> <span class="n">20</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs28', 86)" onmouseover="showTip(event, 'fs28', 86)" class="fn">intervalMs</span> <span class="n">30</span><span class="pn">)</span>
</code></pre>
<p>The sequence <code>either</code> emits an element every 20ms and every 30ms.</p>
<h2><a name="Combine-Latest" class="anchor" href="#Combine-Latest">Combine Latest</a></h2>
<p><code>AsyncSeq.combineLatest</code> non-deterministically merges two async sequences much like <code>AsyncSeq.merge</code>, combining their elements using the specified <code>combine</code> function. The resulting async sequence will only contain elements if both of the source sequences produce at least one element. After combining the first elements the source sequences, this operation emits elements when either source sequence emits an element, passing the newly emitted element as one of the arguments to the <code>combine</code> function, the other being the previously emitted element of that type.</p>
<h3><a name="Example-Execution-2" class="anchor" href="#Example-Execution-2">Example Execution</a></h3>
<p>An example execution can be depicted visually as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">----------------------------------------</span>
<span class="pn">|</span> <span class="id">source1</span> <span class="pn">|</span> <span class="id">a0</span> <span class="pn">|</span>    <span class="pn">|</span>    <span class="pn">|</span> <span class="id">a1</span> <span class="pn">|</span>   <span class="pn">|</span> <span class="id">a2</span> <span class="pn">|</span>
<span class="pn">|</span> <span class="id">source2</span> <span class="pn">|</span>    <span class="pn">|</span> <span class="id">b0</span> <span class="pn">|</span> <span class="id">b1</span> <span class="pn">|</span>    <span class="pn">|</span>   <span class="pn">|</span>    <span class="pn">|</span>
<span class="pn">|</span> <span class="id">result</span>  <span class="pn">|</span>    <span class="pn">|</span> <span class="id">c0</span> <span class="pn">|</span> <span class="id">c1</span> <span class="pn">|</span> <span class="id">c2</span> <span class="pn">|</span>   <span class="pn">|</span> <span class="id">c3</span> <span class="pn">|</span>
<span class="o">----------------------------------------</span>

<span class="id">where</span>

<span class="id">c0</span> <span class="o">=</span> <span class="id">f</span> <span class="id">a0</span> <span class="id">b0</span>
<span class="id">c1</span> <span class="o">=</span> <span class="id">f</span> <span class="id">a0</span> <span class="id">b1</span>
<span class="id">c2</span> <span class="o">=</span> <span class="id">f</span> <span class="id">a1</span> <span class="id">b1</span>
<span class="id">c3</span> <span class="o">=</span> <span class="id">f</span> <span class="id">a2</span> <span class="id">b1</span>
</code></pre>
<h3><a name="Use-Case-2" class="anchor" href="#Use-Case-2">Use Case</a></h3>
<p>Suppose we would like to trigger an operation whenever a change occurs. We can represent changes as an <code>AsyncSeq</code>. To gain intuition for this, consider the <a href="https://www.consul.io/">Consul</a>
configuration management system. It stores configuration information in a tree-like structure. For this purpose of this discussion, it can be thought of as a key-value store
exposed via HTTP. In addition, <code>Consul</code> supports change notifications using HTTP long-polling - when an HTTP GET request is made to retrieve the value of a key,
if the request specified a modify-index, <code>Consul</code> won't respond to the request until a change has occurred <em>since</em> the modify-index. We can represent this operation using
the type <code>Key * ModifyIndex -&gt; Async&lt;Value * ModifyIndex&gt;</code>. Next, we can take this operation and turn it into an <code>AsyncSeq</code> of changes as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs36', 87)" onmouseover="showTip(event, 'fs36', 87)" class="rt">Key</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 88)" onmouseover="showTip(event, 'fs8', 88)" class="rt">string</span>

<span class="k">type</span> <span onmouseout="hideTip(event, 'fs37', 89)" onmouseover="showTip(event, 'fs37', 89)" class="rt">Value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 90)" onmouseover="showTip(event, 'fs8', 90)" class="rt">string</span>

<span class="k">type</span> <span onmouseout="hideTip(event, 'fs38', 91)" onmouseover="showTip(event, 'fs38', 91)" class="vt">ModifyIndex</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs6', 92)" onmouseover="showTip(event, 'fs6', 92)" class="vt">int64</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs39', 93)" onmouseover="showTip(event, 'fs39', 93)" class="fn">longPollKey</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs40', 94)" onmouseover="showTip(event, 'fs40', 94)" class="fn">key</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs36', 95)" onmouseover="showTip(event, 'fs36', 95)" class="rt">Key</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs41', 96)" onmouseover="showTip(event, 'fs41', 96)" class="fn">mi</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs38', 97)" onmouseover="showTip(event, 'fs38', 97)" class="vt">ModifyIndex</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs14', 98)" onmouseover="showTip(event, 'fs14', 98)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs37', 99)" onmouseover="showTip(event, 'fs37', 99)" class="rt">Value</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs38', 100)" onmouseover="showTip(event, 'fs38', 100)" class="vt">ModifyIndex</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 101)" onmouseover="showTip(event, 'fs11', 101)" class="fn">failwith</span> <span class="s">&quot;undefined&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs42', 102)" onmouseover="showTip(event, 'fs42', 102)" class="fn">changes</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs40', 103)" onmouseover="showTip(event, 'fs40', 103)" class="fn">key</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs36', 104)" onmouseover="showTip(event, 'fs36', 104)" class="rt">Key</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs41', 105)" onmouseover="showTip(event, 'fs41', 105)" class="fn">mi</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs38', 106)" onmouseover="showTip(event, 'fs38', 106)" class="vt">ModifyIndex</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 107)" onmouseover="showTip(event, 'fs10', 107)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs37', 108)" onmouseover="showTip(event, 'fs37', 108)" class="rt">Value</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs10', 109)" onmouseover="showTip(event, 'fs10', 109)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs43', 110)" onmouseover="showTip(event, 'fs43', 110)" class="id">unfoldAsync</span> 
    <span class="pn">(</span><span class="k">fun</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs41', 111)" onmouseover="showTip(event, 'fs41', 111)" class="fn">mi</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs38', 112)" onmouseover="showTip(event, 'fs38', 112)" class="vt">ModifyIndex</span><span class="pn">)</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs44', 113)" onmouseover="showTip(event, 'fs44', 113)" class="k">async</span> <span class="pn">{</span>
      <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs45', 114)" onmouseover="showTip(event, 'fs45', 114)" class="fn">value</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs41', 115)" onmouseover="showTip(event, 'fs41', 115)" class="fn">mi</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs39', 116)" onmouseover="showTip(event, 'fs39', 116)" class="fn">longPollKey</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs40', 117)" onmouseover="showTip(event, 'fs40', 117)" class="fn">key</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs41', 118)" onmouseover="showTip(event, 'fs41', 118)" class="fn">mi</span><span class="pn">)</span>
      <span class="k">return</span> <span onmouseout="hideTip(event, 'fs46', 119)" onmouseover="showTip(event, 'fs46', 119)" class="uc">Some</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs45', 120)" onmouseover="showTip(event, 'fs45', 120)" class="fn">value</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs41', 121)" onmouseover="showTip(event, 'fs41', 121)" class="fn">mi</span><span class="pn">)</span> <span class="pn">}</span><span class="pn">)</span>
    <span onmouseout="hideTip(event, 'fs41', 122)" onmouseover="showTip(event, 'fs41', 122)" class="fn">mi</span>
</code></pre>
<p>The function <code>changes</code> produces an async sequence which emits elements whenever the value corresponding to the key changes. Suppose also that we would like to trigger an operation
whenever the key changes or based on a fixed interval. We can represent a fixed interval as an async sequence as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs47', 123)" onmouseover="showTip(event, 'fs47', 123)" class="fn">intervalMs</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs29', 124)" onmouseover="showTip(event, 'fs29', 124)" class="fn">periodMs</span><span class="pn">:</span><span onmouseout="hideTip(event, 'fs18', 125)" onmouseover="showTip(event, 'fs18', 125)" class="vt">int</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs30', 126)" onmouseover="showTip(event, 'fs30', 126)" class="k">asyncSeq</span> <span class="pn">{</span>
  <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs31', 127)" onmouseover="showTip(event, 'fs31', 127)" class="vt">DateTime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 128)" onmouseover="showTip(event, 'fs32', 128)" class="id">UtcNow</span>
  <span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs14', 129)" onmouseover="showTip(event, 'fs14', 129)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs33', 130)" onmouseover="showTip(event, 'fs33', 130)" class="id">Sleep</span> <span onmouseout="hideTip(event, 'fs29', 131)" onmouseover="showTip(event, 'fs29', 131)" class="fn">periodMs</span>
    <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs31', 132)" onmouseover="showTip(event, 'fs31', 132)" class="vt">DateTime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 133)" onmouseover="showTip(event, 'fs32', 133)" class="id">UtcNow</span> <span class="pn">}</span>
</code></pre>
<p>Putting it all together:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 134)" onmouseover="showTip(event, 'fs48', 134)" class="id">changesOrInterval</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 135)" onmouseover="showTip(event, 'fs10', 135)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs37', 136)" onmouseover="showTip(event, 'fs37', 136)" class="rt">Value</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs10', 137)" onmouseover="showTip(event, 'fs10', 137)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs49', 138)" onmouseover="showTip(event, 'fs49', 138)" class="id">combineLatestWith</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs50', 139)" onmouseover="showTip(event, 'fs50', 139)" class="fn">v</span> <span class="id">_</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs50', 140)" onmouseover="showTip(event, 'fs50', 140)" class="fn">v</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs42', 141)" onmouseover="showTip(event, 'fs42', 141)" class="fn">changes</span> <span class="pn">(</span><span class="s">&quot;myKey&quot;</span><span class="pn">,</span> <span class="n">0L</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs47', 142)" onmouseover="showTip(event, 'fs47', 142)" class="fn">intervalMs</span> <span class="pn">(</span><span class="n">1000</span> <span class="o">*</span> <span class="n">60</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>We can now consume this async sequence and use it to trigger downstream operations, such as updating the configuration of a running program, in flight.</p>
<h2><a name="Distinct-Until-Changed" class="anchor" href="#Distinct-Until-Changed">Distinct Until Changed</a></h2>
<p><code>AsyncSeq.distinctUntilChanged</code> returns an async sequence which returns every element of the source sequence, skipping elements which equal its predecessor.</p>
<h2><a name="Example-Execution-3" class="anchor" href="#Example-Execution-3">Example Execution</a></h2>
<p>An example execution can be visualized as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">-----------------------------------</span>
<span class="pn">|</span> <span class="id">source</span>  <span class="pn">|</span> <span class="id">a</span> <span class="pn">|</span> <span class="id">a</span> <span class="pn">|</span> <span class="id">b</span> <span class="pn">|</span> <span class="id">b</span> <span class="pn">|</span> <span class="id">b</span> <span class="pn">|</span> <span class="id">a</span> <span class="pn">|</span>
<span class="pn">|</span> <span class="id">result</span>  <span class="pn">|</span> <span class="id">a</span> <span class="pn">|</span>   <span class="pn">|</span> <span class="id">b</span> <span class="pn">|</span>   <span class="pn">|</span>   <span class="pn">|</span> <span class="id">a</span> <span class="pn">|</span>
<span class="o">-----------------------------------</span>
</code></pre>
<h3><a name="Use-Case-3" class="anchor" href="#Use-Case-3">Use Case</a></h3>
<p>Suppose you're polling a resource which returns status information of a background job.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs51', 143)" onmouseover="showTip(event, 'fs51', 143)" class="rt">Status</span> <span class="o">=</span> <span class="pn">{</span>
  <span onmouseout="hideTip(event, 'fs52', 144)" onmouseover="showTip(event, 'fs52', 144)" class="prop">completed</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs18', 145)" onmouseover="showTip(event, 'fs18', 145)" class="vt">int</span>
  <span onmouseout="hideTip(event, 'fs53', 146)" onmouseover="showTip(event, 'fs53', 146)" class="prop">finished</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs54', 147)" onmouseover="showTip(event, 'fs54', 147)" class="vt">bool</span>
  <span onmouseout="hideTip(event, 'fs55', 148)" onmouseover="showTip(event, 'fs55', 148)" class="prop">result</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 149)" onmouseover="showTip(event, 'fs8', 149)" class="rt">string</span>
<span class="pn">}</span>

<span class="c">/// Gets the status of a job.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs56', 150)" onmouseover="showTip(event, 'fs56', 150)" class="id">status</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs14', 151)" onmouseover="showTip(event, 'fs14', 151)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs51', 152)" onmouseover="showTip(event, 'fs51', 152)" class="rt">Status</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 153)" onmouseover="showTip(event, 'fs11', 153)" class="fn">failwith</span> <span class="s">&quot;&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 154)" onmouseover="showTip(event, 'fs57', 154)" class="id">statuses</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 155)" onmouseover="showTip(event, 'fs10', 155)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs51', 156)" onmouseover="showTip(event, 'fs51', 156)" class="rt">Status</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs30', 157)" onmouseover="showTip(event, 'fs30', 157)" class="k">asyncSeq</span> <span class="pn">{</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs58', 158)" onmouseover="showTip(event, 'fs58', 158)" class="fn">s</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs56', 159)" onmouseover="showTip(event, 'fs56', 159)" class="id">status</span>
    <span class="k">while</span> <span class="k">true</span> <span class="k">do</span>
      <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs14', 160)" onmouseover="showTip(event, 'fs14', 160)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs33', 161)" onmouseover="showTip(event, 'fs33', 161)" class="id">Sleep</span> <span class="n">1000</span>
      <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs58', 162)" onmouseover="showTip(event, 'fs58', 162)" class="fn">s</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs56', 163)" onmouseover="showTip(event, 'fs56', 163)" class="id">status</span>
      <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs58', 164)" onmouseover="showTip(event, 'fs58', 164)" class="fn">s</span> <span class="pn">}</span>
</code></pre>
<p>The async sequence <code>statuses</code> will return a status every second. It will return a status regardless of whether the status changed. Assuming the status changes monotonically, we can use <code>AsyncSeq.distinctUntilChanged</code> to transform <code>statuses</code> into an async sequence of distinct statuses:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs59', 165)" onmouseover="showTip(event, 'fs59', 165)" class="id">distinctStatuses</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 166)" onmouseover="showTip(event, 'fs10', 166)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs51', 167)" onmouseover="showTip(event, 'fs51', 167)" class="rt">Status</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs57', 168)" onmouseover="showTip(event, 'fs57', 168)" class="id">statuses</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 169)" onmouseover="showTip(event, 'fs10', 169)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs60', 170)" onmouseover="showTip(event, 'fs60', 170)" class="id">distinctUntilChanged</span>
</code></pre>
<p>Finally, we can create a workflow which prints the status every time a change is detected and terminates when the underlying job reaches the <code>finished</code> state:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs61', 171)" onmouseover="showTip(event, 'fs61', 171)" class="id">result</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs14', 172)" onmouseover="showTip(event, 'fs14', 172)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs8', 173)" onmouseover="showTip(event, 'fs8', 173)" class="rt">string</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs59', 174)" onmouseover="showTip(event, 'fs59', 174)" class="id">distinctStatuses</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 175)" onmouseover="showTip(event, 'fs10', 175)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs62', 176)" onmouseover="showTip(event, 'fs62', 176)" class="id">pick</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs63', 177)" onmouseover="showTip(event, 'fs63', 177)" class="fn">st</span> <span class="k">-&gt;</span> 
    <span onmouseout="hideTip(event, 'fs64', 178)" onmouseover="showTip(event, 'fs64', 178)" class="fn">printfn</span> <span class="s">&quot;status=</span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs63', 179)" onmouseover="showTip(event, 'fs63', 179)" class="fn">st</span>
    <span class="k">if</span> <span onmouseout="hideTip(event, 'fs63', 180)" onmouseover="showTip(event, 'fs63', 180)" class="fn">st</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs53', 181)" onmouseover="showTip(event, 'fs53', 181)" class="id">finished</span> <span class="k">then</span> <span onmouseout="hideTip(event, 'fs46', 182)" onmouseover="showTip(event, 'fs46', 182)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs63', 183)" onmouseover="showTip(event, 'fs63', 183)" class="fn">st</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs55', 184)" onmouseover="showTip(event, 'fs55', 184)" class="id">result</span>
    <span class="k">else</span> <span onmouseout="hideTip(event, 'fs65', 185)" onmouseover="showTip(event, 'fs65', 185)" class="uc">None</span><span class="pn">)</span>
</code></pre>
<h2><a name="Zip" class="anchor" href="#Zip">Zip</a></h2>
<p><code>AsyncSeq.zip : AsyncSeq&lt;'a&gt; -&gt; AsyncSeq&lt;'b&gt; -&gt; AsyncSeq&lt;'a * 'b&gt;</code> takes a pair of sequences and combines them into a sequence of pairs element wise - the first element of one sequence is paired with the first element of the other, and so on. It can be used to pair sequences of related elements into a single sequence. It can also be used to combine a sequence of elements with a sequence of effects.</p>
<h3><a name="Example-Execution-4" class="anchor" href="#Example-Execution-4">Example Execution</a></h3>
<p>An example execution can be visually depicted as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">---------------------------------------------</span>
<span class="pn">|</span> <span class="id">source1</span>  <span class="pn">|</span>    <span class="id">a1</span>    <span class="pn">|</span>    <span class="id">a2</span>    <span class="pn">|</span>          <span class="pn">|</span>
<span class="pn">|</span> <span class="id">source2</span>  <span class="pn">|</span>    <span class="id">b1</span>    <span class="pn">|</span>    <span class="id">b2</span>    <span class="pn">|</span>    <span class="id">b3</span>    <span class="pn">|</span>
<span class="pn">|</span> <span class="id">result</span>   <span class="pn">|</span>  <span class="id">a1</span> <span class="pn">*</span> <span class="id">b1</span> <span class="pn">|</span>  <span class="id">a2</span> <span class="pn">*</span> <span class="id">b2</span> <span class="pn">|</span>          <span class="pn">|</span> 
<span class="o">---------------------------------------------</span>
</code></pre>
<p>Note that the resulting sequence terminates when either input sequence terminates.</p>
<h3><a name="Use-Case-4" class="anchor" href="#Use-Case-4">Use Case</a></h3>
<p>Suppose that we have an async sequence of events consumed from a message bus. We would like to process this sequence but we want to ensure that we're not processing to fast. We can pair the sequence of events with a sequence of durations corresponding to the minimum consumption time. We can do this as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs66', 186)" onmouseover="showTip(event, 'fs66', 186)" class="id">events</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 187)" onmouseover="showTip(event, 'fs10', 187)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs4', 188)" onmouseover="showTip(event, 'fs4', 188)" class="rt">Event</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 189)" onmouseover="showTip(event, 'fs11', 189)" class="fn">failwith</span> <span class="s">&quot;TODO&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs67', 190)" onmouseover="showTip(event, 'fs67', 190)" class="id">eventsAtLeastOneSec</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs10', 191)" onmouseover="showTip(event, 'fs10', 191)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs68', 192)" onmouseover="showTip(event, 'fs68', 192)" class="id">zipWith</span> 
    <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs69', 193)" onmouseover="showTip(event, 'fs69', 193)" class="fn">a</span> <span class="id">_</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs69', 194)" onmouseover="showTip(event, 'fs69', 194)" class="fn">a</span><span class="pn">)</span> 
    <span onmouseout="hideTip(event, 'fs66', 195)" onmouseover="showTip(event, 'fs66', 195)" class="id">events</span> 
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs10', 196)" onmouseover="showTip(event, 'fs10', 196)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs70', 197)" onmouseover="showTip(event, 'fs70', 197)" class="id">replicateInfiniteAsync</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs14', 198)" onmouseover="showTip(event, 'fs14', 198)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs33', 199)" onmouseover="showTip(event, 'fs33', 199)" class="id">Sleep</span> <span class="n">1000</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>The resulting async sequence <code>eventsAtLeastOneSec</code> will emit an element at-most every second. Note that the input sequence of timeouts is infinite - this is to allow the other sequence to have any length since <code>AsyncSeq.zipWith</code> will terminate when either input sequence terminates.</p>
<h2><a name="Buffer-by-Time-and-Count" class="anchor" href="#Buffer-by-Time-and-Count">Buffer by Time and Count</a></h2>
<p><code>AsyncSeq.bufferByTimeAndCount</code> consumes the input sequence until a specified number of elements are consumed or a timeout expires at which point the resulting sequence emits the buffered of elements, unless no elements have been buffered. It is similar to <code>AsyncSeq.bufferByCount</code> but allows a buffer to be emitted base on a timeout in addition to buffer size. Both are useful for batching inputs before performing an operation. <code>AsyncSeq.bufferByTimeAndCount</code> allows an async workflow to proceed even if there are no inputs received during a certain time period.</p>
<h3><a name="Example-Execution-5" class="anchor" href="#Example-Execution-5">Example Execution</a></h3>
<p>An example execution can be visually depicted as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">-------------------------------------------------------</span>
<span class="pn">|</span> <span class="id">source</span>   <span class="pn">|</span>  <span class="id">a1</span> <span class="pn">|</span> <span class="id">a2</span> <span class="pn">|</span> <span class="id">a3</span>         <span class="pn">|</span> <span class="id">a4</span>      <span class="pn">|</span>        <span class="pn">|</span>
<span class="pn">|</span> <span class="id">result</span>   <span class="pn">|</span>     <span class="pn">|</span>    <span class="pn">|</span> <span class="pn">[</span><span class="id">a1</span><span class="pn">,</span><span class="id">a2</span><span class="pn">,</span><span class="id">a3</span><span class="pn">]</span> <span class="pn">|</span>         <span class="pn">|</span>  <span class="pn">[</span><span class="id">a4</span><span class="pn">]</span>  <span class="pn">|</span>
<span class="o">-------------------------------------------------------</span>
</code></pre>
<p>The last event <code>a4</code> is emitted after a timeout.</p>
<h3><a name="Use-Case-5" class="anchor" href="#Use-Case-5">Use Case</a></h3>
<p>Suppose we're writing a service which consumes a stream of events and indexes them into full-text search index. We can index each event one by one, however we get a performance improvement if we buffer events into small batches. We can buffer into fixed size batches using <code>AsyncSeq.bufferByCount</code>. However, the source event stream may stop emitting events half way through a batch which would leave those events in the buffer until more events arrive. <code>AsyncSeq.bufferByTimeAndCount</code> allows the async workflow to make progress by imposing a bound on how long a non-empty but incomplete buffer can wait more additional items.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs71', 200)" onmouseover="showTip(event, 'fs71', 200)" class="id">individualEvents</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 201)" onmouseover="showTip(event, 'fs10', 201)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs4', 202)" onmouseover="showTip(event, 'fs4', 202)" class="rt">Event</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs11', 203)" onmouseover="showTip(event, 'fs11', 203)" class="fn">failwith</span> <span class="s">&quot;&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs72', 204)" onmouseover="showTip(event, 'fs72', 204)" class="id">bufferSize</span> <span class="o">=</span> <span class="n">100</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs73', 205)" onmouseover="showTip(event, 'fs73', 205)" class="id">bufferTimeout</span> <span class="o">=</span> <span class="n">1000</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs74', 206)" onmouseover="showTip(event, 'fs74', 206)" class="id">bufferedEvents</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs10', 207)" onmouseover="showTip(event, 'fs10', 207)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs4', 208)" onmouseover="showTip(event, 'fs4', 208)" class="rt">Event</span><span class="pn">[</span><span class="pn">]</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs66', 209)" onmouseover="showTip(event, 'fs66', 209)" class="id">events</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 210)" onmouseover="showTip(event, 'fs10', 210)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs27', 211)" onmouseover="showTip(event, 'fs27', 211)" class="id">bufferByCountAndTime</span> <span onmouseout="hideTip(event, 'fs72', 212)" onmouseover="showTip(event, 'fs72', 212)" class="id">bufferSize</span> <span onmouseout="hideTip(event, 'fs73', 213)" onmouseover="showTip(event, 'fs73', 213)" class="id">bufferTimeout</span>   
</code></pre>

            <div class="fsdocs-tip" id="fs1">namespace System</div>
<div class="fsdocs-tip" id="fs2">Multiple items<br />namespace FSharp<br /><br />--------------------<br />namespace Microsoft.FSharp</div>
<div class="fsdocs-tip" id="fs3">Multiple items<br />namespace FSharp.Control<br /><br />--------------------<br />namespace Microsoft.FSharp.Control</div>
<div class="fsdocs-tip" id="fs4">Multiple items<br />module Event

from Microsoft.FSharp.Control<br /><em>&lt;summary&gt;Contains operations for working with values of type &lt;see cref=&quot;T:Microsoft.FSharp.Control.IEvent`1&quot; /&gt;.&lt;/summary&gt;<br />&lt;category index=&quot;3&quot;&gt;Events and Observables&lt;/category&gt;</em><br /><br />--------------------<br />type Event =
  { entityId: int64
    data: string }<br /><br />--------------------<br />type Event&lt;&#39;T&gt; =
  new : unit -&gt; Event&lt;&#39;T&gt;
  member Trigger : arg:&#39;T -&gt; unit
  member Publish : IEvent&lt;&#39;T&gt;<br /><em>&lt;summary&gt;Event implementations for the IEvent&amp;lt;_&amp;gt; type.&lt;/summary&gt;<br />&lt;category index=&quot;3&quot;&gt;Events and Observables&lt;/category&gt;</em><br /><br />--------------------<br />type Event&lt;&#39;Delegate,&#39;Args (requires delegate and &#39;Delegate :&gt; Delegate)&gt; =
  new : unit -&gt; Event&lt;&#39;Delegate,&#39;Args&gt;
  member Trigger : sender:obj * args:&#39;Args -&gt; unit
  member Publish : IEvent&lt;&#39;Delegate,&#39;Args&gt;<br /><em>&lt;summary&gt;Event implementations for a delegate types following the standard .NET Framework convention of a first &#39;sender&#39; argument.&lt;/summary&gt;<br />&lt;category index=&quot;3&quot;&gt;Events and Observables&lt;/category&gt;</em><br /><br />--------------------<br />new : unit -&gt; Event&lt;&#39;T&gt;<br /><br />--------------------<br />new : unit -&gt; Event&lt;&#39;Delegate,&#39;Args&gt;</div>
<div class="fsdocs-tip" id="fs5">Event.entityId: int64</div>
<div class="fsdocs-tip" id="fs6">Multiple items<br />val int64 : value:&#39;T -&gt; int64 (requires member op_Explicit)<br /><em>&lt;summary&gt;Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int64.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted int64&lt;/returns&gt;</em><br /><br />--------------------<br />[&lt;Struct&gt;]
type int64 = Int64<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Int64&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em><br /><br />--------------------<br />type int64&lt;&#39;Measure&gt; =
  int64<br /><em>&lt;summary&gt;The type of 64-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;see cref=&quot;T:System.Int64&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types with Units of Measure&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs7">Event.data: string</div>
<div class="fsdocs-tip" id="fs8">Multiple items<br />val string : value:&#39;T -&gt; string<br /><em>&lt;summary&gt;Converts the argument to a string using &lt;c&gt;ToString&lt;/c&gt;.&lt;/summary&gt;<br />&lt;remarks&gt;For standard integer and floating point values the and any type that implements &lt;c&gt;IFormattable&lt;/c&gt;&lt;c&gt;ToString&lt;/c&gt; conversion uses &lt;c&gt;CultureInfo.InvariantCulture&lt;/c&gt;. &lt;/remarks&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted string.&lt;/returns&gt;</em><br /><br />--------------------<br />type string = String<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.String&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs9">val stream : AsyncSeq&lt;Event&gt;</div>
<div class="fsdocs-tip" id="fs10">Multiple items<br />module AsyncSeq

from FSharp.Control<br /><br />--------------------<br />type AsyncSeq&lt;&#39;T&gt; = IAsyncEnumerable&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 An asynchronous sequence represents a delayed computation that can be
 started to give an enumerator for pulling results asynchronously
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs11">val failwith : message:string -&gt; &#39;T<br /><em>&lt;summary&gt;Throw a &lt;see cref=&quot;T:System.Exception&quot; /&gt; exception.&lt;/summary&gt;<br />&lt;param name=&quot;message&quot;&gt;The exception message.&lt;/param&gt;<br />&lt;returns&gt;The result value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs12">val action : e:Event -&gt; Async&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs13">val e : Event</div>
<div class="fsdocs-tip" id="fs14">Multiple items<br />type Async =
  static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)
  static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)
  static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt; + 1 overload
  static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member CancelDefaultToken : unit -&gt; unit
  static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;
  static member Choice : computations:seq&lt;Async&lt;&#39;T option&gt;&gt; -&gt; Async&lt;&#39;T option&gt;
  static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; + 3 overloads
  static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;
  ...<br /><em>&lt;summary&gt;Holds static members for creating and manipulating asynchronous computations.&lt;/summary&gt;<br />&lt;remarks&gt;
  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em><br /><br />--------------------<br />type Async&lt;&#39;T&gt; =<br /><em>&lt;summary&gt;
 An asynchronous computation, which, when run, will eventually produce a value  of type T, or else raises an exception.
 &lt;/summary&gt;<br />&lt;remarks&gt;
  This type has no members. Asynchronous computations are normally specified either by using an async expression
  or the static methods in the &lt;see cref=&quot;T:Microsoft.FSharp.Control.Async&quot; /&gt; type.

  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;namespacedoc&gt;&lt;summary&gt;
   Library functionality for asynchronous programming, events and agents. See also
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;Asynchronous Programming&lt;/a&gt;, 
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/events&quot;&gt;Events&lt;/a&gt; and
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lazy-expressions&quot;&gt;Lazy Expressions&lt;/a&gt; in the
   F# Language Guide.
 &lt;/summary&gt;&lt;/namespacedoc&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs15">type unit = Unit<br /><em>&lt;summary&gt;The type &#39;unit&#39;, which has only one value &quot;()&quot;. This value is special and
 always uses the representation &#39;null&#39;.&lt;/summary&gt;<br />&lt;category index=&quot;1&quot;&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs16">val iterAsync : action:(&#39;T -&gt; Async&lt;unit&gt;) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br /><em>&lt;summary&gt;
 Iterates over the input sequence and calls the specified asynchronous function for
 every value. The input sequence will be asked for the next element after
 the processing of an element completes.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs17">val groupBy : projection:(&#39;T -&gt; &#39;Key) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;Key * AsyncSeq&lt;&#39;T&gt;&gt; (requires equality)<br /><em>&lt;summary&gt;
 Applies a key-generating function to each element and returns an async sequence containing unique keys
 and async sequences containing elements corresponding to the key.

 Note that the resulting async sequence has to be processed in parallel (e.g AsyncSeq.mapAsyncParallel) becaused
 completion of sub-sequences depends on completion of other sub-sequences.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs18">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><em>&lt;summary&gt;Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted int&lt;/returns&gt;</em><br /><br />--------------------<br />[&lt;Struct&gt;]
type int = int32<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em><br /><br />--------------------<br />type int&lt;&#39;Measure&gt; =
  int<br /><em>&lt;summary&gt;The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types with Units of Measure&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs19">val mapAsyncParallel : mapping:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; s:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;U&gt;<br /><em>&lt;summary&gt;
 Builds a new asynchronous sequence whose elements are generated by
 applying the specified function to all elements of the input sequence.

 The function is applied to elements in order and results are emitted in order,
 but in parallel, without waiting for a prior mapping operation to complete.
 Parallelism is bound by the ThreadPool.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs20">val snd : tuple:(&#39;T1 * &#39;T2) -&gt; &#39;T2<br /><em>&lt;summary&gt;Return the second element of a tuple, &lt;c&gt;snd (a,b) = b&lt;/c&gt;.&lt;/summary&gt;<br />&lt;param name=&quot;tuple&quot;&gt;The input tuple.&lt;/param&gt;<br />&lt;returns&gt;The second value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs21">val iter : action:(&#39;T -&gt; unit) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br /><em>&lt;summary&gt;
 Iterates over the input sequence and calls the specified function for
 every value.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs22">val ignore : value:&#39;T -&gt; unit<br /><em>&lt;summary&gt;Ignore the passed value. This is often used to throw away results of a computation.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The value to ignore.&lt;/param&gt;</em></div>
<div class="fsdocs-tip" id="fs23">val batchStream : AsyncSeq&lt;Event []&gt;</div>
<div class="fsdocs-tip" id="fs24">val batchAction : es:Event [] -&gt; Async&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs25">val es : Event []</div>
<div class="fsdocs-tip" id="fs26">val concatSeq : source:AsyncSeq&lt;#seq&lt;&#39;T&gt;&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Flattens an AsyncSeq of synchronous sequences.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs27">val bufferByCountAndTime : bufferSize:int -&gt; timeoutMs:int -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T []&gt;<br /><em>&lt;summary&gt;
 Buffer items from the async sequence until a specified buffer size is reached or a specified amount of time is elapsed.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs28">val intervalMs : periodMs:int -&gt; AsyncSeq&lt;DateTime&gt;<br /><em>&#160;Represents an stream emitting elements on a specified interval.</em></div>
<div class="fsdocs-tip" id="fs29">val periodMs : int</div>
<div class="fsdocs-tip" id="fs30">val asyncSeq : AsyncSeq.AsyncSeqBuilder<br /><em>&lt;summary&gt;
 Builds an asynchronous sequence using the computation builder syntax
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs31">Multiple items<br />[&lt;Struct&gt;]
type DateTime =
  new : year: int * month: int * day: int -&gt; unit + 16 overloads
  member Add : value: TimeSpan -&gt; DateTime
  member AddDays : value: float -&gt; DateTime
  member AddHours : value: float -&gt; DateTime
  member AddMicroseconds : value: float -&gt; DateTime
  member AddMilliseconds : value: float -&gt; DateTime
  member AddMinutes : value: float -&gt; DateTime
  member AddMonths : months: int -&gt; DateTime
  member AddSeconds : value: float -&gt; DateTime
  member AddTicks : value: int64 -&gt; DateTime
  ...<br /><em>&lt;summary&gt;Represents an instant in time, typically expressed as a date and time of day.&lt;/summary&gt;</em><br /><br />--------------------<br />DateTime ()<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(ticks: int64) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(ticks: int64, kind: DateTimeKind) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(date: DateOnly, time: TimeOnly) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(date: DateOnly, time: TimeOnly, kind: DateTimeKind) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, calendar: Globalization.Calendar) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Globalization.Calendar) : DateTime<br />&#160;&#160;&#160;<em>(+0 other overloads)</em></div>
<div class="fsdocs-tip" id="fs32">property DateTime.UtcNow: DateTime with get<br /><em>&lt;summary&gt;Gets a &lt;see cref=&quot;T:System.DateTime&quot; /&gt; object that is set to the current date and time on this computer, expressed as the Coordinated Universal Time (UTC).&lt;/summary&gt;<br />&lt;returns&gt;An object whose value is the current UTC date and time.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs33">static member Async.Sleep : dueTime:TimeSpan -&gt; Async&lt;unit&gt;<br />static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs34">val either : AsyncSeq&lt;DateTime&gt;</div>
<div class="fsdocs-tip" id="fs35">val merge : source1:AsyncSeq&lt;&#39;T&gt; -&gt; source2:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Merges two async sequences of the same type into an async sequence non-deterministically.
 The resulting async sequence produces elements when any argument sequence produces an element.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs36">type Key = string</div>
<div class="fsdocs-tip" id="fs37">type Value = string</div>
<div class="fsdocs-tip" id="fs38">[&lt;Struct&gt;]
type ModifyIndex = int64</div>
<div class="fsdocs-tip" id="fs39">val longPollKey : key:Key * mi:ModifyIndex -&gt; Async&lt;Value * ModifyIndex&gt;</div>
<div class="fsdocs-tip" id="fs40">val key : Key</div>
<div class="fsdocs-tip" id="fs41">val mi : ModifyIndex</div>
<div class="fsdocs-tip" id="fs42">val changes : key:Key * mi:ModifyIndex -&gt; AsyncSeq&lt;Value&gt;</div>
<div class="fsdocs-tip" id="fs43">val unfoldAsync : generator:(&#39;State -&gt; Async&lt;(&#39;T * &#39;State) option&gt;) -&gt; state:&#39;State -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Generates an async sequence using the specified asynchronous generator function.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs44">val async : AsyncBuilder<br /><em>&lt;summary&gt;Builds an asynchronous workflow using computation expression syntax.&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs45">val value : Value</div>
<div class="fsdocs-tip" id="fs46">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The representation of &quot;Value of type &#39;T&quot;&lt;/summary&gt;<br />&lt;param name=&quot;Value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;An option representing the value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs47">val intervalMs : periodMs:int -&gt; AsyncSeq&lt;DateTime&gt;</div>
<div class="fsdocs-tip" id="fs48">val changesOrInterval : AsyncSeq&lt;Value&gt;</div>
<div class="fsdocs-tip" id="fs49">val combineLatestWith : combine:(&#39;T -&gt; &#39;U -&gt; &#39;V) -&gt; source1:AsyncSeq&lt;&#39;T&gt; -&gt; source2:AsyncSeq&lt;&#39;U&gt; -&gt; AsyncSeq&lt;&#39;V&gt;<br /><em>&lt;summary&gt;
 Merges two async sequences using the specified combine function. The resulting async sequence produces an element when either
 input sequence produces an element, passing the new element from the emitting sequence and the previously emitted element from the other sequence.
 If either of the input sequences is empty, the resulting sequence is empty.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs50">val v : Value</div>
<div class="fsdocs-tip" id="fs51">type Status =
  { completed: int
    finished: bool
    result: string }</div>
<div class="fsdocs-tip" id="fs52">Status.completed: int</div>
<div class="fsdocs-tip" id="fs53">Status.finished: bool</div>
<div class="fsdocs-tip" id="fs54">[&lt;Struct&gt;]
type bool = Boolean<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs55">Status.result: string</div>
<div class="fsdocs-tip" id="fs56">val status : Async&lt;Status&gt;<br /><em>&#160;Gets the status of a job.</em></div>
<div class="fsdocs-tip" id="fs57">val statuses : AsyncSeq&lt;Status&gt;</div>
<div class="fsdocs-tip" id="fs58">val s : Status</div>
<div class="fsdocs-tip" id="fs59">val distinctStatuses : AsyncSeq&lt;Status&gt;</div>
<div class="fsdocs-tip" id="fs60">val distinctUntilChanged : source:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt; (requires equality)<br /><em>&lt;summary&gt;
 Returns an async sequence which contains no contiguous duplicate elements.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs61">val result : Async&lt;string&gt;</div>
<div class="fsdocs-tip" id="fs62">val pick : chooser:(&#39;T -&gt; &#39;TResult option) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;&#39;TResult&gt;<br /><em>&lt;summary&gt;
 Asynchronously pick a value from a sequence based on the specified chooser function.
 Raises KeyNotFoundException if the chooser function can&#39;t find a matching key.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs63">val st : Status</div>
<div class="fsdocs-tip" id="fs64">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><em>&lt;summary&gt;Print to &lt;c&gt;stdout&lt;/c&gt; using the given format, and add a newline.&lt;/summary&gt;<br />&lt;param name=&quot;format&quot;&gt;The formatter.&lt;/param&gt;<br />&lt;returns&gt;The formatted result.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs65">union case Option.None: Option&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The representation of &quot;No value&quot;&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs66">val events : AsyncSeq&lt;Event&gt;</div>
<div class="fsdocs-tip" id="fs67">val eventsAtLeastOneSec : AsyncSeq&lt;Event&gt;</div>
<div class="fsdocs-tip" id="fs68">val zipWith : mapping:(&#39;T1 -&gt; &#39;T2 -&gt; &#39;U) -&gt; source1:AsyncSeq&lt;&#39;T1&gt; -&gt; source2:AsyncSeq&lt;&#39;T2&gt; -&gt; AsyncSeq&lt;&#39;U&gt;<br /><em>&lt;summary&gt;
 Combines two asynchronous sequences using the specified function.
 The resulting sequence stops when either of the argument sequences stop.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs69">val a : Event</div>
<div class="fsdocs-tip" id="fs70">val replicateInfiniteAsync : v:Async&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Creates an infinite async sequence which repeatedly evaluates and emits the specified async value.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs71">val individualEvents : AsyncSeq&lt;Event&gt;</div>
<div class="fsdocs-tip" id="fs72">val bufferSize : int</div>
<div class="fsdocs-tip" id="fs73">val bufferTimeout : int</div>
<div class="fsdocs-tip" id="fs74">val bufferedEvents : AsyncSeq&lt;Event []&gt;</div>

        </div>

        <!-- BEGIN SEARCH BOX: this adds support for the search box -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
        <script type="text/javascript">var fsdocs_search_baseurl = '/FSharp.Control.AsyncSeq/';</script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
        <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-search.js"></script>
        <!-- END SEARCH BOX: this adds support for the search box -->
    </div>
</body>

</html>