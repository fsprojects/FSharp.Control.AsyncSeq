<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>F# Async: FSharp.Control.AsyncSeq
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="">

    <link rel="stylesheet" id="theme_link" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.6.0/materia/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns" crossorigin="anonymous"></script>

    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico">
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/navbar-fixed-left.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/FSharp.Control.AsyncSeq/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-light bg-secondary fixed-left" id="fsdocs-nav">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse navbar-nav-scroll" id="navbarsExampleDefault">
            <a href="/FSharp.Control.AsyncSeq/"><img id="fsdocs-logo" src="/FSharp.Control.AsyncSeq/img/logo.png" /></a>
            <!-- BEGIN SEARCH BOX: this adds support for the search box -->
            <div id="header">
                <div class="searchbox" id="fsdocs-searchbox">
                    <label for="search-by">
                        <i class="fas fa-search"></i>
                    </label>
                    <input data-search-input="" id="search-by" type="search" placeholder="Search..." />
                    <span data-search-clear="">
                        <i class="fas fa-times"></i>
                    </span>
                </div>
            </div>

            <!-- END SEARCH BOX: this adds support for the search box -->
            <ul class="navbar-nav">
                <li class="nav-header">Links</li>
                <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License</a></li>
                <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                <li class="nav-header">
  Documentation
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/ComparisonWithObservable.html">
    Comparison with IObservable

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeq.html">
    F# Async: FSharp.Control.AsyncSeq

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/AsyncSeqExamples.html">
    F# AsyncSeq Examples

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/FSharp.Control.AsyncSeq/terminology.html">
    Terminology

  </a>
</li>
                {{fsdocs-list-of-namespaces}}
            </ul>
        </div>
    </nav>
    <div class="container">
        <div class="masthead">
            <h3 class="muted"><a href="/FSharp.Control.AsyncSeq/">FSharp.Control.AsyncSeq</a></h3>
        </div>
        <hr />
        <div class="container" id="fsdocs-content">
            <p><a href="https://mybinder.org/v2/gh/fsprojects/FSharp.Control.AsyncSeq/gh-pages?filepath=AsyncSeq.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a></p>
<h1><a name="F-Async-FSharp-Control-AsyncSeq" class="anchor" href="#F-Async-FSharp-Control-AsyncSeq">F# Async: FSharp.Control.AsyncSeq</a></h1>
<blockquote>
<p>NOTE: There is also the option to use <a href="https://github.com/fsprojects/FSharp.Control.TaskSeq">FSharp.Control.TaskSeq</a> which has a very similar usage model.</p>
</blockquote>
<p>An AsyncSeq is a sequence in which individual elements are retrieved using an <code>Async</code> computation.
It is similar to <code>seq&lt;'a&gt;</code> in that subsequent elements are pulled on-demand.
<code>AsyncSeq</code> also bears similarity to <code>IObservable&lt;'a&gt;</code> with the former being based on an "asynchronous pull" and the
latter based on a "synchronous push". Analogs for most operations defined for <code>Seq</code>, <code>List</code> and <code>IObservable</code> are also defined for
<code>AsyncSeq</code>. The power of <code>AsyncSeq</code> lies in that many of these operations also have analogs based on <code>Async</code>
allowing composition of complex asynchronous workflows.</p>
<blockquote>
<p><strong>v4.0 and later:</strong> <code>AsyncSeq&lt;'T&gt;</code> is a type alias for <code>System.Collections.Generic.IAsyncEnumerable&lt;'T&gt;</code>.
Any <code>IAsyncEnumerable&lt;'T&gt;</code> value (e.g. from EF Core, ASP.NET Core channels, or <code>taskSeq { }</code>) can be used
directly as an <code>AsyncSeq&lt;'T&gt;</code> without conversion, and vice-versa.</p>
</blockquote>
<p>The <code>AsyncSeq</code> type is located in the <code>FSharp.Control.AsyncSeq.dll</code> assembly which can be loaded in F# Interactive as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pp">#r</span> <span class="s">&quot;../../../bin/FSharp.Control.AsyncSeq.dll&quot;</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">FSharp</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">Control</span>
</code></pre>
<h3><a name="Generating-asynchronous-sequences" class="anchor" href="#Generating-asynchronous-sequences">Generating asynchronous sequences</a></h3>
<p>An <code>AsyncSeq&lt;'T&gt;</code> can be generated using computation expression syntax much like <code>seq&lt;'T&gt;</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">async12</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="k">asyncSeq</span> <span class="pn">{</span>
  <span class="k">yield</span> <span class="n">1</span>
  <span class="k">yield</span> <span class="n">2</span>
<span class="pn">}</span>
</code></pre>
<p>Another way to generate an asynchronous sequence is using the <code>Async.unfoldAsync</code> function. This
function accepts as an argument a function which can generate individual elements based on a state and
signal completion of the sequence.</p>
<p>For example, suppose that you're writing a program which consumes the Twitter API and stores tweets
which satisfy some criteria into a database. There are several asynchronous request-reply interactions at play -
one to retrieve a batch of tweets from the Twitter API, another to determine whether a tweet satisfies some
criteria and finally an operation to write the desired tweet to a database.</p>
<p>Given the type <code>Tweet</code> to represent an individual tweet, the operation to retrieve a batch of tweets can
be modeled with type <code>int -&gt; Async&lt;(Tweet[] * int) option&gt;</code> where the incoming <code>int</code> represents the
offset into the tweet stream. The asynchronous result is an <code>Option</code> which when <code>None</code> indicates the
end of the stream, and otherwise contains the batch of retrieved tweets as well as the next offset.</p>
<p>The above function to retrieve a batch of tweets can be used to generate an asynchronous sequence
of tweet batches as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="rt">Tweet</span> <span class="o">=</span> <span class="pn">{</span>
  <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="prop">user</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="rt">string</span>
  <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="prop">message</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="rt">string</span>
<span class="pn">}</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="fn">getTweetBatch</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs10', 11)" onmouseover="showTip(event, 'fs10', 11)" class="fn">offset</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="vt">int</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="rt">Async</span><span class="pn">&lt;</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs5', 14)" onmouseover="showTip(event, 'fs5', 14)" class="rt">Tweet</span><span class="pn">[</span><span class="pn">]</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs11', 15)" onmouseover="showTip(event, 'fs11', 15)" class="vt">int</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="rt">option</span><span class="pn">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="fn">failwith</span> <span class="s">&quot;TODO: call Twitter API&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 18)" onmouseover="showTip(event, 'fs15', 18)" class="id">tweetBatches</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs16', 19)" onmouseover="showTip(event, 'fs16', 19)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 20)" onmouseover="showTip(event, 'fs5', 20)" class="rt">Tweet</span><span class="pn">[</span><span class="pn">]</span><span class="pn">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 22)" onmouseover="showTip(event, 'fs17', 22)" class="id">unfoldAsync</span> <span onmouseout="hideTip(event, 'fs9', 23)" onmouseover="showTip(event, 'fs9', 23)" class="fn">getTweetBatch</span> <span class="n">0</span>
</code></pre>
<p>The asynchronous sequence <code>tweetBatches</code> will when iterated, incrementally consume the entire tweet stream.</p>
<p>Next, suppose that the tweet filtering function makes a call to a web service which determines
whether a particular tweet is of interest and should be stored in the database. This function can be modeled with
type <code>Tweet -&gt; Async&lt;bool&gt;</code>. We can flatten the <code>tweetBatches</code> sequence and then filter it as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 24)" onmouseover="showTip(event, 'fs18', 24)" class="fn">filterTweet</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 25)" onmouseover="showTip(event, 'fs19', 25)" class="fn">t</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs5', 26)" onmouseover="showTip(event, 'fs5', 26)" class="rt">Tweet</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs12', 27)" onmouseover="showTip(event, 'fs12', 27)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs20', 28)" onmouseover="showTip(event, 'fs20', 28)" class="vt">bool</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs14', 29)" onmouseover="showTip(event, 'fs14', 29)" class="fn">failwith</span> <span class="s">&quot;TODO: call web service&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 30)" onmouseover="showTip(event, 'fs21', 30)" class="id">filteredTweets</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs16', 31)" onmouseover="showTip(event, 'fs16', 31)" class="if">AsyncSeq</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 32)" onmouseover="showTip(event, 'fs5', 32)" class="rt">Tweet</span><span class="pn">&gt;</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'fs15', 33)" onmouseover="showTip(event, 'fs15', 33)" class="id">tweetBatches</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 34)" onmouseover="showTip(event, 'fs16', 34)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 35)" onmouseover="showTip(event, 'fs22', 35)" class="id">concatSeq</span> <span class="c">// flatten</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 36)" onmouseover="showTip(event, 'fs16', 36)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs23', 37)" onmouseover="showTip(event, 'fs23', 37)" class="id">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 38)" onmouseover="showTip(event, 'fs18', 38)" class="fn">filterTweet</span> <span class="c">// filter</span>
</code></pre>
<p>When the resulting sequence <code>filteredTweets</code> is consumed, it will lazily consume the underlying
sequence <code>tweetBatches</code>, select individual tweets and filter them using the function <code>filterTweets</code>.</p>
<p>Finally, the function which stores a tweet in the database can be modeled by type <code>Tweet -&gt; Async&lt;unit&gt;</code>.
We can store all filtered tweets as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 39)" onmouseover="showTip(event, 'fs24', 39)" class="fn">storeTweet</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 40)" onmouseover="showTip(event, 'fs19', 40)" class="fn">t</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs5', 41)" onmouseover="showTip(event, 'fs5', 41)" class="rt">Tweet</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs12', 42)" onmouseover="showTip(event, 'fs12', 42)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs25', 43)" onmouseover="showTip(event, 'fs25', 43)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs14', 44)" onmouseover="showTip(event, 'fs14', 44)" class="fn">failwith</span> <span class="s">&quot;TODO: call database&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 45)" onmouseover="showTip(event, 'fs26', 45)" class="id">storeFilteredTweets</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs12', 46)" onmouseover="showTip(event, 'fs12', 46)" class="rt">Async</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs25', 47)" onmouseover="showTip(event, 'fs25', 47)" class="rt">unit</span><span class="pn">&gt;</span> <span class="o">=</span>
  <span onmouseout="hideTip(event, 'fs21', 48)" onmouseover="showTip(event, 'fs21', 48)" class="id">filteredTweets</span>
  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 49)" onmouseover="showTip(event, 'fs16', 49)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs27', 50)" onmouseover="showTip(event, 'fs27', 50)" class="id">iterAsync</span> <span onmouseout="hideTip(event, 'fs24', 51)" onmouseover="showTip(event, 'fs24', 51)" class="fn">storeTweet</span>
</code></pre>
<p>Note that the value <code>storeFilteredTweets</code> is an asynchronous computation of type <code>Async&lt;unit&gt;</code>. At this point,
it is a <em>representation</em> of the workflow which consists of reading batches of tweets, filtering them and storing them
in the database. When executed, the workflow will consume the entire tweet stream. The entire workflow can be
succinctly declared and executed as follows:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs16', 52)" onmouseover="showTip(event, 'fs16', 52)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 53)" onmouseover="showTip(event, 'fs17', 53)" class="id">unfoldAsync</span> <span onmouseout="hideTip(event, 'fs9', 54)" onmouseover="showTip(event, 'fs9', 54)" class="fn">getTweetBatch</span> <span class="n">0</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 55)" onmouseover="showTip(event, 'fs16', 55)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 56)" onmouseover="showTip(event, 'fs22', 56)" class="id">concatSeq</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 57)" onmouseover="showTip(event, 'fs16', 57)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs23', 58)" onmouseover="showTip(event, 'fs23', 58)" class="id">filterAsync</span> <span onmouseout="hideTip(event, 'fs18', 59)" onmouseover="showTip(event, 'fs18', 59)" class="fn">filterTweet</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs16', 60)" onmouseover="showTip(event, 'fs16', 60)" class="m">AsyncSeq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs27', 61)" onmouseover="showTip(event, 'fs27', 61)" class="id">iterAsync</span> <span onmouseout="hideTip(event, 'fs24', 62)" onmouseover="showTip(event, 'fs24', 62)" class="fn">storeTweet</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs12', 63)" onmouseover="showTip(event, 'fs12', 63)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs28', 64)" onmouseover="showTip(event, 'fs28', 64)" class="id">RunSynchronously</span>
</code></pre>
<p>The above snippet effectively orchestrates several asynchronous request-reply interactions into a cohesive unit
composed using familiar operations on sequences. Furthermore, it will be executed efficiently in a non-blocking manner.</p>
<h3><a name="Comparison-with-seq-T" class="anchor" href="#Comparison-with-seq-T">Comparison with seq<'T></a></h3>
<p>The central difference between <code>seq&lt;'T&gt;</code> and <code>AsyncSeq&lt;'T&gt;</code> can be illustrated by introducing the notion of time.
Suppose that generating subsequent elements of a sequence requires an IO-bound operation. Invoking long
running IO-bound operations from within a <code>seq&lt;'T&gt;</code> will <em>block</em> the thread which calls <code>MoveNext</code> on the
corresponding <code>IEnumerator</code>. An <code>AsyncSeq</code> on the other hand can use facilities provided by the F# <code>Async</code> type to make
more efficient use of system resources.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 65)" onmouseover="showTip(event, 'fs29', 65)" class="id">withTime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs30', 66)" onmouseover="showTip(event, 'fs30', 66)" class="fn">seq</span> <span class="pn">{</span>
  <span class="id">Thread</span><span class="pn">.</span><span class="id">Sleep</span><span class="pn">(</span><span class="n">1000</span><span class="pn">)</span> <span class="c">// calling thread will block</span>
  <span class="k">yield</span> <span class="n">1</span>
  <span class="id">Thread</span><span class="pn">.</span><span class="id">Sleep</span><span class="pn">(</span><span class="n">1000</span><span class="pn">)</span> <span class="c">// calling thread will block</span>
  <span class="k">yield</span> <span class="n">1</span>
<span class="pn">}</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs31', 67)" onmouseover="showTip(event, 'fs31', 67)" class="id">withTime&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 68)" onmouseover="showTip(event, 'fs4', 68)" class="k">asyncSeq</span> <span class="pn">{</span>
  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs12', 69)" onmouseover="showTip(event, 'fs12', 69)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 70)" onmouseover="showTip(event, 'fs32', 70)" class="id">Sleep</span> <span class="n">1000</span> <span class="c">// non-blocking sleep</span>
  <span class="k">yield</span> <span class="n">1</span>
  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs12', 71)" onmouseover="showTip(event, 'fs12', 71)" class="rt">Async</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs32', 72)" onmouseover="showTip(event, 'fs32', 72)" class="id">Sleep</span> <span class="n">1000</span> <span class="c">// non-blocking sleep</span>
  <span class="k">yield</span> <span class="n">2</span>
<span class="pn">}</span>
</code></pre>
<p>When the asynchronous sequence <code>withTime'</code> is iterated, the calls to <code>Async.Sleep</code> won't block threads. Instead,
the <em>continuation</em> of the sequence will be scheduled by <code>Async</code> while the calling thread will be free to perform other work.
Overall, a <code>seq&lt;'a&gt;</code> can be viewed as a special case of an <code>AsyncSeq&lt;'a&gt;</code> where subsequent elements are retrieved
in a blocking manner.</p>
<h3><a name="Performance-Considerations" class="anchor" href="#Performance-Considerations">Performance Considerations</a></h3>
<p>While an asynchronous computation obviates the need to block an OS thread for the duration of an operation, it isn't always the case
that this will improve the overall performance of an application. Note however that an async computation does not <em>require</em> a
non-blocking operation, it simply allows for it. Also of note is that unlike calling <code>IEnumerable.MoveNext()</code>, consuming
an item from an asynchronous sequence requires several allocations. Usually this is greatly outweighed by the
benefits, it can make a difference in some scenarios.</p>
<h2><a name="Related-Articles" class="anchor" href="#Related-Articles">Related Articles</a></h2>
<ul>
<li><a href="http://tomasp.net/blog/async-sequences.aspx/">Programming with F# asynchronous sequences</a></li>
</ul>

            <div class="fsdocs-tip" id="fs1">Multiple items<br />namespace FSharp<br /><br />--------------------<br />namespace Microsoft.FSharp</div>
<div class="fsdocs-tip" id="fs2">Multiple items<br />namespace FSharp.Control<br /><br />--------------------<br />namespace Microsoft.FSharp.Control</div>
<div class="fsdocs-tip" id="fs3">val async12 : AsyncSeq&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs4">val asyncSeq : AsyncSeq.AsyncSeqBuilder<br /><em>&lt;summary&gt;
 Builds an asynchronous sequence using the computation builder syntax
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs5">type Tweet =
  { user: string
    message: string }</div>
<div class="fsdocs-tip" id="fs6">Tweet.user: string</div>
<div class="fsdocs-tip" id="fs7">Multiple items<br />val string : value:&#39;T -&gt; string<br /><em>&lt;summary&gt;Converts the argument to a string using &lt;c&gt;ToString&lt;/c&gt;.&lt;/summary&gt;<br />&lt;remarks&gt;For standard integer and floating point values the and any type that implements &lt;c&gt;IFormattable&lt;/c&gt;&lt;c&gt;ToString&lt;/c&gt; conversion uses &lt;c&gt;CultureInfo.InvariantCulture&lt;/c&gt;. &lt;/remarks&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted string.&lt;/returns&gt;</em><br /><br />--------------------<br />type string = System.String<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.String&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs8">Tweet.message: string</div>
<div class="fsdocs-tip" id="fs9">val getTweetBatch : offset:int -&gt; Async&lt;(Tweet [] * int) option&gt;</div>
<div class="fsdocs-tip" id="fs10">val offset : int</div>
<div class="fsdocs-tip" id="fs11">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><em>&lt;summary&gt;Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted int&lt;/returns&gt;</em><br /><br />--------------------<br />[&lt;Struct&gt;]
type int = int32<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em><br /><br />--------------------<br />type int&lt;&#39;Measure&gt; =
  int<br /><em>&lt;summary&gt;The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types with Units of Measure&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs12">Multiple items<br />type Async =
  static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)
  static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)
  static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt; + 1 overload
  static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;
  static member CancelDefaultToken : unit -&gt; unit
  static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;
  static member Choice : computations:seq&lt;Async&lt;&#39;T option&gt;&gt; -&gt; Async&lt;&#39;T option&gt;
  static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; + 3 overloads
  static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;
  ...<br /><em>&lt;summary&gt;Holds static members for creating and manipulating asynchronous computations.&lt;/summary&gt;<br />&lt;remarks&gt;
  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em><br /><br />--------------------<br />type Async&lt;&#39;T&gt; =<br /><em>&lt;summary&gt;
 An asynchronous computation, which, when run, will eventually produce a value  of type T, or else raises an exception.
 &lt;/summary&gt;<br />&lt;remarks&gt;
  This type has no members. Asynchronous computations are normally specified either by using an async expression
  or the static methods in the &lt;see cref=&quot;T:Microsoft.FSharp.Control.Async&quot; /&gt; type.

  See also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;F# Language Guide - Async Workflows&lt;/a&gt;.
 &lt;/remarks&gt;<br />&lt;namespacedoc&gt;&lt;summary&gt;
   Library functionality for asynchronous programming, events and agents. See also
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows&quot;&gt;Asynchronous Programming&lt;/a&gt;, 
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/events&quot;&gt;Events&lt;/a&gt; and
   &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lazy-expressions&quot;&gt;Lazy Expressions&lt;/a&gt; in the
   F# Language Guide.
 &lt;/summary&gt;&lt;/namespacedoc&gt;<br />&lt;category index=&quot;1&quot;&gt;Async Programming&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs13">type &#39;T option = Option&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The type of optional values. When used from other CLI languages the
 empty option is the &lt;c&gt;null&lt;/c&gt; value. &lt;/summary&gt;<br />&lt;remarks&gt;Use the constructors &lt;c&gt;Some&lt;/c&gt; and &lt;c&gt;None&lt;/c&gt; to create values of this type.
 Use the values in the &lt;c&gt;Option&lt;/c&gt; module to manipulate values of this type,
 or pattern match against the values directly.

 &#39;None&#39; values will appear as the value &lt;c&gt;null&lt;/c&gt; to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of &lt;c&gt;null&lt;/c&gt; as a value representation.&lt;/remarks&gt;<br />&lt;category index=&quot;3&quot;&gt;Options&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs14">val failwith : message:string -&gt; &#39;T<br /><em>&lt;summary&gt;Throw a &lt;see cref=&quot;T:System.Exception&quot; /&gt; exception.&lt;/summary&gt;<br />&lt;param name=&quot;message&quot;&gt;The exception message.&lt;/param&gt;<br />&lt;returns&gt;The result value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs15">val tweetBatches : AsyncSeq&lt;Tweet []&gt;</div>
<div class="fsdocs-tip" id="fs16">Multiple items<br />module AsyncSeq

from FSharp.Control<br /><br />--------------------<br />type AsyncSeq&lt;&#39;T&gt; = System.Collections.Generic.IAsyncEnumerable&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 An asynchronous sequence; equivalent to System.Collections.Generic.IAsyncEnumerable&amp;lt;&#39;T&amp;gt;.
 Use the asyncSeq { ... } computation expression to create values, and the AsyncSeq module
 for combinators.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs17">val unfoldAsync : generator:(&#39;State -&gt; Async&lt;(&#39;T * &#39;State) option&gt;) -&gt; state:&#39;State -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Generates an async sequence using the specified asynchronous generator function.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs18">val filterTweet : t:Tweet -&gt; Async&lt;bool&gt;</div>
<div class="fsdocs-tip" id="fs19">val t : Tweet</div>
<div class="fsdocs-tip" id="fs20">[&lt;Struct&gt;]
type bool = System.Boolean<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Boolean&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs21">val filteredTweets : AsyncSeq&lt;Tweet&gt;</div>
<div class="fsdocs-tip" id="fs22">val concatSeq : source:AsyncSeq&lt;#seq&lt;&#39;T&gt;&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Flattens an AsyncSeq of synchronous sequences.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs23">val filterAsync : predicate:(&#39;T -&gt; Async&lt;bool&gt;) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 Builds a new asynchronous sequence whose elements are those from the
 input sequence for which the specified function returned true.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs24">val storeTweet : t:Tweet -&gt; Async&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs25">type unit = Unit<br /><em>&lt;summary&gt;The type &#39;unit&#39;, which has only one value &quot;()&quot;. This value is special and
 always uses the representation &#39;null&#39;.&lt;/summary&gt;<br />&lt;category index=&quot;1&quot;&gt;Basic Types&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs26">val storeFilteredTweets : Async&lt;unit&gt;</div>
<div class="fsdocs-tip" id="fs27">val iterAsync : action:(&#39;T -&gt; Async&lt;unit&gt;) -&gt; source:AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br /><em>&lt;summary&gt;
 Iterates over the input sequence and calls the specified asynchronous function for
 every value. The input sequence will be asked for the next element after
 the processing of an element completes.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs28">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:System.Threading.CancellationToken -&gt; &#39;T</div>
<div class="fsdocs-tip" id="fs29">val withTime : seq&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs30">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><em>&lt;summary&gt;Builds a sequence using sequence expression syntax&lt;/summary&gt;<br />&lt;param name=&quot;sequence&quot;&gt;The input sequence.&lt;/param&gt;<br />&lt;returns&gt;The result sequence.&lt;/returns&gt;</em><br /><br />--------------------<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Collections.Generic.IEnumerable`1&quot; /&gt;&lt;/summary&gt;<br />&lt;remarks&gt;
  See the &lt;see cref=&quot;T:Microsoft.FSharp.Collections.SeqModule&quot; /&gt; module for further operations related to sequences.

  See also &lt;a href=&quot;https://docs.microsoft.com/dotnet/fsharp/language-reference/sequences&quot;&gt;F# Language Guide - Sequences&lt;/a&gt;.
&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs31">val withTime&#39; : AsyncSeq&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs32">static member Async.Sleep : dueTime:System.TimeSpan -&gt; Async&lt;unit&gt;<br />static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>

        </div>

        <!-- BEGIN SEARCH BOX: this adds support for the search box -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
        <script type="text/javascript">var fsdocs_search_baseurl = '/FSharp.Control.AsyncSeq/';</script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
        <script type="text/javascript" src="/FSharp.Control.AsyncSeq/content/fsdocs-search.js"></script>
        <!-- END SEARCH BOX: this adds support for the search box -->
    </div>
</body>

</html>